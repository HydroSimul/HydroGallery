# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' **utilize functions**
#' @name utilis
NULL

#' @rdname utilis
#' @param vec_Data (vector of num / int) data
#' @param int_Index (vector of int) index of subset
#' @export
subset_get <- function(vec_Data, int_Index) {
    .Call(`_HydroGallery_subset_get`, vec_Data, int_Index)
}

#' @rdname utilis
#' @export
subset_get_logical <- function(vec_Data, int_Index) {
    .Call(`_HydroGallery_subset_get_logical`, vec_Data, int_Index)
}

#' @rdname utilis
#' @param vec_DataPut (vector of num / int) data, to refresh
#' @export
subset_put <- function(vec_Data, int_Index, vec_DataPut) {
    invisible(.Call(`_HydroGallery_subset_put`, vec_Data, int_Index, vec_DataPut))
}

#' @rdname utilis
#' @param vec_DataAdd (vector of num / int) data, to refresh
#' @export
subset_add <- function(vec_Data, int_Index, vec_DataAdd) {
    invisible(.Call(`_HydroGallery_subset_add`, vec_Data, int_Index, vec_DataAdd))
}

#' @rdname utilis
#' @param mat_X,mat_Y (matrix of num / int) data
#' @param num_X0 (vector of num) data
#' @export
linear_interpolate_vec <- function(mat_X, mat_Y, num_X0) {
    .Call(`_HydroGallery_linear_interpolate_vec`, mat_X, mat_Y, num_X0)
}

#' caculate **snowfall**
#' @name atmosSnow
#' @inheritParams all_vari
#' @description
#' \loadmathjax
#' 
#' Under the concept of the conceptual HM, the amount of snowfall is always calculated by the temperature \mjseqn{T} and the precipitation \mjseqn{P} availability. 
#' The proportion of snowfall is always determined by the air temperature.
#' 
#' 
#' So we can give the function from:
#' 
#' \mjsdeqn{P_s = f_{atmosSnow}(D_{atms})}
#' 
#' 
#' to:
#' 
#' \mjsdeqn{P_s = f_{atmosSnow}(P, T) = k^*P}
#' \mjsdeqn{0 \leq k^* \leq 1}
#' where
#'   - \mjseqn{P} is `ATMOS_precpitation_mm`
#'   - \mjseqn{T} is `ATMOS_teperature_Cel`
#' - \mjseqn{k^*} is estimated portion
#' 
#' Then the different `atmosSnow` methods will estimate the portion \mjseqn{k^*}.
#' 
#' 
#' The output density distribution from 2 methods:
#' 
#' @references
#' \insertAllCited{}
#' @return ATMOS_snow_mm (mm/m2/TS) snowfall volume
#' @details
#' # **_ThresholdT**: 
#' 
#' 
#' Only a temperature is as the threshold defined, so estimate the portion \mjseqn{k^*} as: 
#' \mjsdeqn{k^{*}=1, \quad T \leq T_s}
#' where
#'   - \mjseqn{T_s} is `param_ATMOS_thr_Ts`
#' 
#' @param param_ATMOS_thr_Ts <-1, 3> (Cel) threshold air temperature that snow, parameter for [atmosSnow_ThresholdT()]
#' @export
atmosSnow_ThresholdT <- function(ATMOS_precipitation_mm, ATMOS_temperature_Cel, param_ATMOS_thr_Ts) {
    .Call(`_HydroGallery_atmosSnow_ThresholdT`, ATMOS_precipitation_mm, ATMOS_temperature_Cel, param_ATMOS_thr_Ts)
}

#' @rdname atmosSnow
#' @details
#' # **_UBC** \insertCite{UBC_Quick_1977}{HydroGallery}: 
#' 
#' 
#' estimate the portion \mjseqn{k^*}{} as:
#' \mjsdeqn{k^* = 1- \frac{T}{T_0}}
#' \mjsdeqn{k^* \geq 0}
#' where
#'   - \mjseqn{T_0} is `param_ATMOS_ubc_A0FORM`
#' 
#' @param param_ATMOS_ubc_A0FORM <0.01, 3> (Cel) threshold air temperature that snow, it can not equal or small than 0, parameter for [atmosSnow_UBC()]
#' @export
atmosSnow_UBC <- function(ATMOS_precipitation_mm, ATMOS_temperature_Cel, param_ATMOS_ubc_A0FORM) {
    .Call(`_HydroGallery_atmosSnow_UBC`, ATMOS_precipitation_mm, ATMOS_temperature_Cel, param_ATMOS_ubc_A0FORM)
}

#' **baseflow**
#' @name baseflow
#' @inheritParams all_vari
#' @description
#' \loadmathjax
#' 
#' In hydrological modeling, baseflow refers to the flow of water in rivers and streams that is sustained by the release of water from the groundwater.
#' Or baseflow refers to the flow of water from an aquifer or deeper soil horizon to surface water, typically due to a head gradient between fully saturated soil and stream  \insertCite{Raven_Manual_35}{HydroGallery}. 
#' It may be considered the sum of the contribution of deep groundwater exchange with a river and delayed storage  \insertCite{Raven_Manual_35}{HydroGallery}.
#' 
#' It is always calculated (only) by the water in the ground layer \mjseqn{W_{grnd}}, which can also be treated as part of \mjseqn{W_{grnd}}. 
#' However, the impact of other RUs (response units) on the route to the river will be ignored.
#' 
#' So we can give the function from:
#' 
#' \mjsdeqn{F_{base} = f_{baseflow}(D_{grnd})}
#' 
#' 
#' to:
#' 
#' \mjsdeqn{F_{base} = f_{baseflow}(W_{grnd}, C_{grnd}, M_{base}, ...)}
#' \mjsdeqn{F_{base} = k^* W_{grnd} \quad {\rm or} \quad F_{base} = k^* M_{base}}
#' \mjsdeqn{0 \leq k^* \leq 1}
#' 
#' 
#' where
#' - \mjseqn{W_{grnd}} is `GROUND_water_mm`
#' - \mjseqn{M_{base}} is `GROUND_potentialBaseflow_mm`
#' - \mjseqn{C_{grnd}} is `GROUND_capacity_mm`, but not all the methods need the \mjseqn{C_{grnd}}
#' - \mjseqn{k^*} is estimated ratio
#' 
#' The output density distribution from 7 methods:
#'
#' @references
#' \insertAllCited{}
#' @return GROUND_baseflow_mm (mm/m2/TS) 
#' @details
#' # **_GR4J** \insertCite{GR4J_Perrin_2003}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{F_{base} = k^* W_{grnd}}
#' \mjsdeqn{k^* = 1 - \left[ 1 + \left(\frac{W_{grnd}}{C_{grnd}} \right)^4 \right]^{-1/4}}
#' where
#'   - \mjseqn{k^*} is estimated ratio
#' @export
baseflow_GR4J <- function(GROUND_water_mm, GROUND_capacity_mm) {
    .Call(`_HydroGallery_baseflow_GR4J`, GROUND_water_mm, GROUND_capacity_mm)
}

#' @rdname baseflow
#' @details
#' # **_GR4Jfix** \insertCite{GR4J_Perrin_2003}{HydroGallery}: 
#'
#' 
#' This method based on `_GR4J` use a new parameter to replace the numer 4:
#' \mjsdeqn{F_{base} = k^* W_{grnd}}
#' \mjsdeqn{k^* = 1 - \left[ 1 + \left(\frac{W_{grnd}}{C_{grnd}} \right)^\gamma \right]^{-1/\gamma}}
#' where
#'   - \mjseqn{\gamma} is `param_BASEFLOW_grf_gamma`
#' @param param_BASEFLOW_grf_gamma <2, 7> exponential parameter for [baseflow_GR4Jfix()]
#' @export
baseflow_GR4Jfix <- function(GROUND_water_mm, GROUND_capacity_mm, param_BASEFLOW_grf_gamma) {
    .Call(`_HydroGallery_baseflow_GR4Jfix`, GROUND_water_mm, GROUND_capacity_mm, param_BASEFLOW_grf_gamma)
}

#' @rdname baseflow
#' @details
#' # **_SupplyRatio**: 
#'
#' 
#' \mjsdeqn{F_{base} = k W_{grnd}}
#' where
#'   - \mjseqn{k} is `param_BASEFLOW_sur_k`
#' @param param_BASEFLOW_sur_k <0.01, 1> coefficient parameter for [baseflow_SupplyRatio()]
#' @export
baseflow_SupplyRatio <- function(GROUND_water_mm, param_BASEFLOW_sur_k) {
    .Call(`_HydroGallery_baseflow_SupplyRatio`, GROUND_water_mm, param_BASEFLOW_sur_k)
}

#' @rdname baseflow
#' @details
#' # **_SupplyPow**: 
#'
#' 
#' \mjsdeqn{F_{base} = k(W_{grnd})^\gamma}
#' where
#'   - \mjseqn{k} is `param_BASEFLOW_sup_k`
#'   - \mjseqn{\gamma} is `param_BASEFLOW_sup_gamma`
#' @param param_BASEFLOW_sup_k <0.01, 1> coefficient parameter for [baseflow_SupplyPow()]
#' @param param_BASEFLOW_sup_gamma <0, 1> exponential parameter for [baseflow_SupplyPow()]
#' @export
baseflow_SupplyPow <- function(GROUND_water_mm, param_BASEFLOW_sup_k, param_BASEFLOW_sup_gamma) {
    .Call(`_HydroGallery_baseflow_SupplyPow`, GROUND_water_mm, param_BASEFLOW_sup_k, param_BASEFLOW_sup_gamma)
}

#' @rdname baseflow
#' @details
#' # **_MaxPow**: 
#'
#' 
#' \mjsdeqn{F_{base} = M_{base} \left(\frac{W_{grnd}}{C_{grnd}} \right)^\gamma}
#' where
#'   - \mjseqn{M_{base}} is `GROUND_potentialBaseflow_mm`
#'   - \mjseqn{\gamma} is `param_BASEFLOW_map_gamma`
#' @param param_BASEFLOW_map_gamma <0.1, 5> exponential parameter for [baseflow_MaxPow()]
#' @export
baseflow_MaxPow <- function(GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialBaseflow_mm, param_BASEFLOW_map_gamma) {
    .Call(`_HydroGallery_baseflow_MaxPow`, GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialBaseflow_mm, param_BASEFLOW_map_gamma)
}

#' @rdname baseflow
#' @details
#' # **_ThreshPow** 
#'
#' 
#' This method based on the `_MaxPow` and add the one threshold \mjseqn{\phi_b}: 
#' \mjsdeqn{F_{base} = 0, \quad \frac{W_{grnd}}{C_{grnd}} < \phi_b}
#' \mjsdeqn{F_{base} = M_{base} \left(\frac{\frac{W_{grnd}}{C_{grnd}} - \phi_b}{1-\phi_b} \right)^\gamma, \quad \frac{W_{grnd}}{C_{grnd}} \geq \phi_b}
#' where
#'   - \mjseqn{\phi_b} is `param_BASEFLOW_thp_thresh`
#'   - \mjseqn{\gamma} is `param_BASEFLOW_thp_gamma`
#' @param param_BASEFLOW_thp_thresh <0.1, 0.9> coefficient parameter for [baseflow_ThreshPow()]
#' @param param_BASEFLOW_thp_gamma <0.1, 5> exponential parameter for [baseflow_ThreshPow()]
#' @export
baseflow_ThreshPow <- function(GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialBaseflow_mm, param_BASEFLOW_thp_thresh, param_BASEFLOW_thp_gamma) {
    .Call(`_HydroGallery_baseflow_ThreshPow`, GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialBaseflow_mm, param_BASEFLOW_thp_thresh, param_BASEFLOW_thp_gamma)
}

#' @rdname baseflow
#' @details
#' # **_Arno** \insertCite{baseflow_Arno_1991,VIC2_Liang_1994}{HydroGallery}:
#'
#' 
#' This method has also in two cases divided by a threshold water content \mjseqn{\phi_b}: 
#' \mjsdeqn{F_{base} = k M_{base} \frac{W_{grnd}}{C_{grnd}}, \quad \frac{W_{grnd}}{C_{grnd}} < \phi_b}
#' \mjsdeqn{F_{base} = k M_{base} \frac{W_{grnd}}{C_{grnd}} + (1-k) M_{base} \left(\frac{W_{grnd} - W_s}{C_{grnd} - W_s} \right)^2, \quad \frac{W_{grnd}}{C_{grnd}} \geq \phi_b}
#' \mjsdeqn{W_s = k C_{grnd}}
#' where
#'   - \mjseqn{\phi_b} is `param_BASEFLOW_arn_thresh`
#'   - \mjseqn{k} is `param_BASEFLOW_arn_k`
#' @param param_BASEFLOW_arn_thresh <0.1, 0.9> coefficient parameter for [baseflow_ThreshPow()]
#' @param param_BASEFLOW_arn_k <0.1, 1> exponential parameter for [baseflow_ThreshPow()]
#' @export
baseflow_Arno <- function(GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialBaseflow_mm, param_BASEFLOW_arn_thresh, param_BASEFLOW_arn_k) {
    .Call(`_HydroGallery_baseflow_Arno`, GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialBaseflow_mm, param_BASEFLOW_arn_thresh, param_BASEFLOW_arn_k)
}

#' This function implements a calibration algorithm based on the Direct Search method.
#'
#' It attempts to find the optimal parameter values that minimize the given objective (fitness) function.
#'
#' @param fitness A function handle to the objective function that returns a numeric value
#' @param lst_OtherData A list of other data that may be passed to the fitness function
#' @param x_Min A NumericVector of lower bounds for each parameter
#' @param x_Max A NumericVector of upper bounds for each parameter
#' @param x_Init An optional initial solution (NumericVector), if NULL, the midpoint of `x_Min` and `x_Max` is used
#' @param max_iter The maximum number of iterations to perform (default is 100)
#' @param r The perturbation factor (default is 0.2)
#'
#' @return A List containing:
#'   - `x_Best`: The best parameter set found during the search
#'   - `y_Best`: The corresponding objective value of the best parameter set
#'
#' @export
cali_DDS <- function(fitness, lst_OtherData, x_Min, x_Max, x_Init = NULL, max_iter = 100L, r = 0.2) {
    .Call(`_HydroGallery_cali_DDS`, fitness, lst_OtherData, x_Min, x_Max, x_Init, max_iter, r)
}

#' **potential evapotranspiration**
#' @name evatransPotential
#' @description 
#' 
#' The concept 
#'  
#' @references
#' \insertAllCited{}
#' @inheritParams all_vari
#' @export
landLeafAreaIndex_WaterGAP3 <- function(ATMOS_temperature_Cel, ATMOS_precipitation_mm, CELL_latitude_deg, LAND_growUpDay_d, LAND_leafAreaIndexMin_, LAND_leafAreaIndexMax_, Time_dayOfYear_d) {
    .Call(`_HydroGallery_landLeafAreaIndex_WaterGAP3`, ATMOS_temperature_Cel, ATMOS_precipitation_mm, CELL_latitude_deg, LAND_growUpDay_d, LAND_leafAreaIndexMin_, LAND_leafAreaIndexMax_, Time_dayOfYear_d)
}

#' **capilarise**
#' @name capirise
#' @inheritParams all_vari
#' @description
#' 
#' \loadmathjax
#' 
#' In hydrological modeling, capillary rise refers to the process by which water is drawn upward from groundwater (table) through the soil due to the force of capillary action.
#' In conceptual watershed models, the capillary rise term often refers to a process that moves water from lower to higher soil water stores, 
#' which may also implicitly include lateral groundwater flow processes in a sloping domain.
#' 
#' It can be calculated by the water in the ground layer \mjseqn{W_{grnd}}, which can also be treated as part of \mjseqn{W_{grnd}}. 
#' There are not many methods to describe this process. Most HMs ignore this process, 
#' perhaps because it is not significant in most situations, or because the process of percolation can deal with this process at the same time.
#' 
#' So we can give the function from:
#' 
#' \mjsdeqn{F_{capi} = f_{capirise}(D_{grnd}, D_{soil})}
#' 
#' 
#' to:
#' 
#' \mjsdeqn{F_{capi} = f_{capirise}(W_{grnd}, W_{soil}, C_{soil}, ...)}
#' \mjsdeqn{F_{capi} \leq W_{grnd}}
#' \mjsdeqn{F_{capi} \leq C_{soil} - W_{soil}}
#' 
#' 
#' where
#' - \mjseqn{F_{capi}} is `GROUND_capirise_mm`
#' - \mjseqn{W_{grnd}} is `GROUND_water_mm`
#' - \mjseqn{W_{soil}} is `water_SOIL_mm`
#' - \mjseqn{C_{soil}} is `capacity_SOIL_mm`
#' 
#' The output density distribution from 4 methods:
#'
#' @references
#' \insertAllCited{}
#' @return GROUND_capirise_mm (mm/m2/TS) capillary rise
#' 
#' @details
#' # **_HBV** \insertCite{HBV_Lindstrom_1997}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{F_{capi} = M_{capi} \left( 1 - \frac{W_{soil}}{C_{soil}} \right)}
#' where
#'   - \mjseqn{M_{capi}} is `SOIL_potentialCapirise_mm`
#'   
#' @export
capirise_HBV <- function(GROUND_water_mm, SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialCapirise_mm) {
    .Call(`_HydroGallery_capirise_HBV`, GROUND_water_mm, SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialCapirise_mm)
}

#' @rdname capirise
#' @details
#' # **_HBVfix** \insertCite{HBV_Lindstrom_1997}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{F_{capi} = M_{capi} \left( 1 - \frac{W_{soil}}{k_{fc}C_{soil}} \right), \quad W_{soil} < k_{fc}C_{soil}}
#' where
#'   - \mjseqn{k_{fc}} is `SOIL_fieldCapacityPerc_1`
#' @export
capirise_HBVfix <- function(GROUND_water_mm, SOIL_water_mm, SOIL_capacity_mm, SOIL_fieldCapacityPerc_1, SOIL_potentialCapirise_mm) {
    .Call(`_HydroGallery_capirise_HBVfix`, GROUND_water_mm, SOIL_water_mm, SOIL_capacity_mm, SOIL_fieldCapacityPerc_1, SOIL_potentialCapirise_mm)
}

#' @rdname capirise
#' @details
#' # **_AcceptRatio**: 
#'
#' 
#' \mjsdeqn{F_{capi} = k \left( W_{soil} - k_{fc}C_{soil} \right), \quad W_{soil} < k_{fc}C_{soil}}
#' where
#'   - \mjseqn{k} is `param_CAPIRISE_acr_k`
#'   - \mjseqn{k_{fc}} is `SOIL_fieldCapacityPerc_1`
#' @param param_CAPIRISE_acr_k <0.01, 1> coefficient parameter [capirise_AcceptRatio()]
#' @export
capirise_AcceptRatio <- function(GROUND_water_mm, SOIL_water_mm, SOIL_capacity_mm, SOIL_fieldCapacityPerc_1, param_CAPIRISE_acr_k) {
    .Call(`_HydroGallery_capirise_AcceptRatio`, GROUND_water_mm, SOIL_water_mm, SOIL_capacity_mm, SOIL_fieldCapacityPerc_1, param_CAPIRISE_acr_k)
}

#' @rdname capirise
#' @details
#' # **_AcceptRatio**: 
#'
#' 
#' \mjsdeqn{F_{capi} = k \left( W_{soil} - k_{fc}C_{soil} \right)^\gamma, \quad W_{soil} < k_{fc}C_{soil}}
#' where
#'   - \mjseqn{k} is `param_CAPIRISE_acp_k`
#'   - \mjseqn{\gamma} is `param_CAPIRISE_acp_gamma`
#'   
#' @param param_CAPIRISE_acp_k <0.01, 1> coefficient parameter for [capirise_AcceptPow()]
#' @param param_CAPIRISE_acp_gamma <0.01, 1> exponential parameter for [capirise_AcceptPow()]
#' @export
capirise_AcceptPow <- function(GROUND_water_mm, SOIL_water_mm, SOIL_capacity_mm, SOIL_fieldCapacityPerc_1, param_CAPIRISE_acp_k, param_CAPIRISE_acp_gamma) {
    .Call(`_HydroGallery_capirise_AcceptPow`, GROUND_water_mm, SOIL_water_mm, SOIL_capacity_mm, SOIL_fieldCapacityPerc_1, param_CAPIRISE_acp_k, param_CAPIRISE_acp_gamma)
}

#' **confluence**
#' @description 
#' \loadmathjax
#' 
#' In hydrological modeling, routing (named as [confluen] in HydroGallery) refers to the process of simulating the movement of water through a river network or other drainage system. 
#' It allows the model to predict the flow of water in rivers and streams. 
#' In hydrological models, routing is typically performed using mathematical algorithms that account for the physical properties of the river network, 
#' such as its geometry, roughness, and discharge capacity. 
#' The parameters that govern routing, such as flow velocity and channel roughness, 
#' can have a significant impact on the accuracy of the model.
#' 
#' `confluence` is a calculation function that causes water to flow into the gauge point.
#' - `IUH`: IUH (Instant Unit Hydrograph) with one watercourse, 
#' - `IUH2S`: IUH with two water sources, each with a different IUH vector, 
#' - `IUH3S`: IUH with three water sources, each with a different IUH vector.
#' 
#' Under the concept of the conceptual HM, the water flux to the water flow will be calculated using the confluence process. 
#' This process does not calculate the water balance, but rather the time-varying nature of the water flow. 
#' The "Instant Unit Hydrograph" method is the most effective way to deal with time-varying flows. 
#' In the first stage, only [confluenIUH] will be supported.
#' 
#' So we can give the function:
#' 
#' \mjsdeqn{Q = f_{confluen}(F, u)}
#' 
#' 
#' 
#' where
#' - \mjseqn{Q} is stream flow, but still in mm/TS not m3/TS or m3/S
#' - \mjseqn{F} is flux that will into river conflen, e.g.`LAND_runoff_mm`, `SOIL_interflow_mm` or `GROUND_baseflow_mm`
#' - \mjseqn{u} is Instant Unit Hydrograph series
#' 
#' @references
#' \insertAllCited{}
#' @name confluen
#' @inheritParams all_vari
#' @return confluenced water (mm/m2)
#' @export
confluen_IUH <- function(CONFLUEN_inputWater_mm, CONFLUEN_iuh_1) {
    .Call(`_HydroGallery_confluen_IUH`, CONFLUEN_inputWater_mm, CONFLUEN_iuh_1)
}

#' @rdname confluen
#' @export
confluen_IUH2S <- function(LAND_runoff_mm, GROUND_baseflow_mm, CONFLUEN_iuhLand_1, CONFLUEN_iuhGround_1) {
    .Call(`_HydroGallery_confluen_IUH2S`, LAND_runoff_mm, GROUND_baseflow_mm, CONFLUEN_iuhLand_1, CONFLUEN_iuhGround_1)
}

#' @rdname confluen
#' @export
confluen_IUH3S <- function(LAND_runoff_mm, SOIL_interflow_mm, GROUND_baseflow_mm, CONFLUEN_iuhLand_1, CONFLUEN_iuhSoil_1, CONFLUEN_iuhGround_1) {
    .Call(`_HydroGallery_confluen_IUH3S`, LAND_runoff_mm, SOIL_interflow_mm, GROUND_baseflow_mm, CONFLUEN_iuhLand_1, CONFLUEN_iuhSoil_1, CONFLUEN_iuhGround_1)
}

#' create **IUH** (Instant Unit Hydrograph)
#' @name confluenIUH
#' @inheritParams all_vari
#' @description
#' \loadmathjax
#' 
#' The process `confluenIUH` return a series of portions, that means how many flux water will
#' in those moment into the river.
#' The sum of this series will always in 1.
#' 
#' So we can give the function:
#' 
#' \mjsdeqn{u = f_{confluenIUH}(t_r, ...)}
#' 
#' 
#' 
#' where
#' - \mjseqn{u} is series of portions
#' - \mjseqn{t_r} is  `CONFLUEN_responseTime_TS`
#' 
#' @references
#' \insertAllCited{}
#' @return IUH (list of num vector) 
#' @details
#' # **_GR4J1** \insertCite{GR4J_Perrin_2003}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{u(i) = S(i) - S(i-1)}
#' \mjsdeqn{S(i) = \left( \frac{i}{t_r} \right)^{2.5}, \quad 0 \leq i \leq t_r}
#' where
#'   - \mjseqn{u} is IUH series
#'   - \mjseqn{i} is index
#' @export
confluenIUH_GR4J1 <- function(CONFLUEN_responseTime_TS) {
    .Call(`_HydroGallery_confluenIUH_GR4J1`, CONFLUEN_responseTime_TS)
}

#' @rdname confluenIUH
#' @details
#' # **_GR4J2** \insertCite{GR4J_Perrin_2003}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{u(i) = S(i) - S(i-1)}
#' \mjsdeqn{S(i) = 0.5\left( \frac{i}{t_r} \right)^{2.5}, \quad 0 \leq i \leq t_r}
#' \mjsdeqn{S(i) = 1 - 0.5\left(2 - \frac{i}{t_r} \right)^{2.5}, \quad t_r < i < 2t_r}
#' \mjsdeqn{S(i) = 0, \quad i = 2t_r}
#' where
#'   - \mjseqn{u} is IUH series
#'   - \mjseqn{i} is index
#' @export
confluenIUH_GR4J2 <- function(CONFLUEN_responseTime_TS) {
    .Call(`_HydroGallery_confluenIUH_GR4J2`, CONFLUEN_responseTime_TS)
}

#' @rdname confluenIUH
#' @details
#' # **_Kelly** \insertCite{iuh_Kelly_1955}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{u(i) = \frac{4}{t_r^2} \left( i + k \left( e^{-i/k} \right) \right), \quad i \leq t_r / 2 }
#' \mjsdeqn{u(i) = - \frac{4}{t_r^2}(i - k - t_r) + \frac{4ke^{-i/k}}{t_r^2} (1 - 2 e^{t_r/(2k)}), \quad t_r / 2 < i \leq t_r }
#' \mjsdeqn{u(i) =  \frac{4ke^{-i/k}}{t_r^2} (1 - 2 e^{t_r/(2k)} +  e^{t_r/k}), \quad i > t_r }
#' where
#'   - \mjseqn{k} is `param_CONFLUEN_kel_k`
#' @param param_CONFLUEN_kel_k <1, 4> parameter for[confluenIUH_Kelly()]
#' @export
confluenIUH_Kelly <- function(CONFLUEN_responseTime_TS, param_CONFLUEN_kel_k) {
    .Call(`_HydroGallery_confluenIUH_Kelly`, CONFLUEN_responseTime_TS, param_CONFLUEN_kel_k)
}

#' @rdname confluenIUH
#' @details
#' # **_Nash** \insertCite{iuh_Nash_1957}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{u(i) = \frac{1}{t_r\Gamma(n)} \left(\frac{4}{t_r^2}\right)^{n -1}e^{-i/t_r}}
#' where
#'   - \mjseqn{n} is `param_CONFLUEN_nas_n`
#' @param param_CONFLUEN_nas_n <1, 8> parameter for[confluenIUH_Nash()]
#' @export
confluenIUH_Nash <- function(CONFLUEN_responseTime_TS, param_CONFLUEN_nas_n) {
    .Call(`_HydroGallery_confluenIUH_Nash`, CONFLUEN_responseTime_TS, param_CONFLUEN_nas_n)
}

#' @rdname confluenIUH
#' @details
#' # **_Clark** \insertCite{iuh_Clark_1945}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{u(i) = \frac{1}{t_r} e^{-i/t_r} }
#' where
#'   - \mjseqn{t_r} is `CONFLUEN_responseTime_TS`
#' @export
confluenIUH_Clark <- function(CONFLUEN_responseTime_TS) {
    .Call(`_HydroGallery_confluenIUH_Clark`, CONFLUEN_responseTime_TS)
}

#' @rdname confluen
#' @export
confluen_WaterGAP3_H <- function(RIVER_water_m3, RIVER_length_km, RIVER_velocity_km, RIVER_outflow_m3, CELL_cellNumberStep_int, CELL_inflowCellNumberStep_int) {
    .Call(`_HydroGallery_confluen_WaterGAP3_H`, RIVER_water_m3, RIVER_length_km, RIVER_velocity_km, RIVER_outflow_m3, CELL_cellNumberStep_int, CELL_inflowCellNumberStep_int)
}

#' @rdname confluen
#' @export
confluen_WaterGAP3_L <- function(RIVER_water_m3, RIVER_length_km, RIVER_velocity_km, RIVER_outflow_m3, CELL_cellNumberStep_int, CELL_inflowCellNumberStep_int, Riverlak_cellNumber_int, Riverlak_water_m3, Riverlak_capacity_m3, param_Riverlak_lin_storeFactor) {
    .Call(`_HydroGallery_confluen_WaterGAP3_L`, RIVER_water_m3, RIVER_length_km, RIVER_velocity_km, RIVER_outflow_m3, CELL_cellNumberStep_int, CELL_inflowCellNumberStep_int, Riverlak_cellNumber_int, Riverlak_water_m3, Riverlak_capacity_m3, param_Riverlak_lin_storeFactor)
}

#' @rdname confluen
#' @export
confluen_WaterGAP3_N <- function(RIVER_water_m3, RIVER_length_km, RIVER_velocity_km, RIVER_inflow_m3, CELL_cellNumberStep_int, CELL_inflowCellNumberStep_int, Riverlak_cellNumber_int, Riverlak_capacity_m3, param_Riverlak_lin_storeFactor) {
    .Call(`_HydroGallery_confluen_WaterGAP3_N`, RIVER_water_m3, RIVER_length_km, RIVER_velocity_km, RIVER_inflow_m3, CELL_cellNumberStep_int, CELL_inflowCellNumberStep_int, Riverlak_cellNumber_int, Riverlak_capacity_m3, param_Riverlak_lin_storeFactor)
}

#' @rdname confluen
#' @export
confluen_WaterGAP3 <- function(RIVER_water_m3, RIVER_length_km, RIVER_velocity_km, RIVER_outflow_m3, CELL_cellNumberStep_int, CELL_inflowCellNumberStep_int, Riverlak_cellNumber_int, Riverlak_capacity_m3, Reservoi_cellNumber_int, Reservoi_inflow_m3, Reservoi_demand_m3, Reservoi_capacity_m3, Reservoi_meanInflow_m3, Reservoi_meanDemand_m3, Reservoi_releaseCoefficient_1, Reservoi_isIrrigate_01, param_Riverlak_lin_storeFactor) {
    .Call(`_HydroGallery_confluen_WaterGAP3`, RIVER_water_m3, RIVER_length_km, RIVER_velocity_km, RIVER_outflow_m3, CELL_cellNumberStep_int, CELL_inflowCellNumberStep_int, Riverlak_cellNumber_int, Riverlak_capacity_m3, Reservoi_cellNumber_int, Reservoi_inflow_m3, Reservoi_demand_m3, Reservoi_capacity_m3, Reservoi_meanInflow_m3, Reservoi_meanDemand_m3, Reservoi_releaseCoefficient_1, Reservoi_isIrrigate_01, param_Riverlak_lin_storeFactor)
}

#' Evalute matrics
#' @name eva
#' @param num_Sim A numeric vector of simulated values.
#' @param num_Obs A numeric vector of observed values. NA values are removed along with corresponding values in num_Sim.
#' @return A double representing the Evalute matrics.
#' @export
evalute_NSE <- function(num_Sim, num_Obs) {
    .Call(`_HydroGallery_evalute_NSE`, num_Sim, num_Obs)
}

#' @rdname eva
#' @param factor_r,factor_alpha,factor_beta A double specifying the weight for the correlation term (r - 1), (alpha - 1) and (beta - 1). Default is 1.0.
#' @export
evalute_KGE <- function(num_Sim, num_Obs, factor_r = 1.0, factor_alpha = 1.0, factor_beta = 1.0) {
    .Call(`_HydroGallery_evalute_KGE`, num_Sim, num_Obs, factor_r, factor_alpha, factor_beta)
}

#' **potential evapotranspiration**
#' @name evatransPotential
#' @description 
#' 
#' The concept of potential evapotranspiration (ET) estimates the ability of water lost from the soil and vegetation in an area due to evaporation and transpiration. 
#' It assumes that there is always enough water in the ET area to meet the demand for evapotranspiration.
#' However, the characteristics of the ET area, such as whether it is covered with vegetation or bare soil, can affect the amount of evapotranspiration that occurs. 
#' In order to accurately estimate potential ET, we need to consider these characteristics. 
#' 
#' But we may not always have access to the necessary information or effective methods to do this.
#' In these cases, we can use a simplified method known as **reference ET**. 
#' This method defines the ET area using certain fixed characteristics, such as those provided by the [evatransPotential_FAO56()] function. 
#' In this situation, we need to provide factors to account for the differences between the actual ET area and the reference ET area.
#' 
#' @references
#' \insertAllCited{}
#' @inheritParams all_vari
#' @details
#' - **_TurcWendling** \insertCite{ET_TurcWendling_1991}{HydroGallery}: consider only the radiation and temperature as the main factors. 
#' \mjsdeqn{E_p = \frac{(100 R_s + 3.875 t_h k)\cdot(T + 22)}{150 (T + 123)}}
#' where
#'   - \mjseqn{E_p} is potential ET, `ATMOS_potentialEvatrans_mm`
#'   - \mjseqn{R_s} is solar radiation, `ATMOS_solarRadiat_MJ`
#'   - \mjseqn{t_h} is time step in hour, `time_step_h`
#'   - \mjseqn{T} is average air temperature, `ATMOS_temperature_Cel`
#'   - \mjseqn{k} is `param_EVATRANS_tur_k`
#' @param param_EVATRANS_tur_k <0.6, 1> parameter for [evatransPotential_TurcWendling()], higher value when closer to the sea
#' @return potential evapotranspiration (mm/m2)
#' @export
evatransPotential_TurcWendling <- function(ATMOS_temperature_Cel, ATMOS_solarRadiat_MJ, param_EVATRANS_tur_k) {
    .Call(`_HydroGallery_evatransPotential_TurcWendling`, ATMOS_temperature_Cel, ATMOS_solarRadiat_MJ, param_EVATRANS_tur_k)
}

#' @rdname evatransPotential
#' @details
#' - **_Linacre** \insertCite{ET_Linacre_1977}{HydroGallery}: consider only the temperature as the main factors. 
#' \mjsdeqn{E_p = \frac{\frac{100(0.75 - \alpha)(T + 0.006 z)}{100 - \phi} + 15(T - T_d)}{80 - T}}
#' \mjsdeqn{T_d = T - 20 (1-H_R)}
#' where
#'   - \mjseqn{\alpha} is albedo, `LAND_albedo_1`
#'   - \mjseqn{z} is elevation, `LAND_elevation_m`
#'   - \mjseqn{T_d} is dewpoint temperature,
#'   - \mjseqn{H_R} is relative humidity, `ATMOS_relativeHumidity_1`
#' @export
evatransPotential_Linacre <- function(ATMOS_temperature_Cel, ATMOS_relativeHumidity_1, LAND_latitude_Degree, LAND_elevation_m, LAND_albedo_1) {
    .Call(`_HydroGallery_evatransPotential_Linacre`, ATMOS_temperature_Cel, ATMOS_relativeHumidity_1, LAND_latitude_Degree, LAND_elevation_m, LAND_albedo_1)
}

#' @rdname evatransPotential
#' @details
#' - **_FAO56** \insertCite{ET_FAO56_1998}{HydroGallery}: consider not only radiation and temperature but also other variable like wind speed
#' as the main factors. 
#' \mjsdeqn{E_p =\frac{0.408 \Delta\left(R_n - G\right)+\gamma \frac{900}{T+273} {u}_{2}\left({e}_{{s}}-{e}_{{a}}\right)}{\Delta+\gamma\left(1+0.34 {u}_{2}\right)}}
#' where
#'   - \mjseqn{\Delta} is slope vapour pressure curve (kPa °C-1)
#'   - \mjseqn{R_n} is net radiation, `ATMOS_netRadiat_MJ`
#'   - \mjseqn{G} is soil heat flux density
#'   - \mjseqn{u_2} is wind speed at 2 m height, `ATMOS_windSpeed2m_m_s`
#'   - \mjseqn{e_s} is saturation vapour pressure, `ATMOS_saturatVaporPress_hPa`
#'   - \mjseqn{e_a} is actual vapour pressure, `ATMOS_vaporPress_hPa`
#'   - \mjseqn{\gamma} is psychrometric constant
#' @export
evatransPotential_FAO56 <- function(ATMOS_temperature_Cel, ATMOS_vaporPress_hPa, ATMOS_saturatVaporPress_hPa, ATMOS_netRadiat_MJ, ATMOS_windSpeed2m_m_s, LAND_elevation_m) {
    .Call(`_HydroGallery_evatransPotential_FAO56`, ATMOS_temperature_Cel, ATMOS_vaporPress_hPa, ATMOS_saturatVaporPress_hPa, ATMOS_netRadiat_MJ, ATMOS_windSpeed2m_m_s, LAND_elevation_m)
}

#' @rdname evatransPotential
#' @param param_EVATRANS_prt_alpha <1, 2> parameter for [evatransPotential_PriestleyTaylor()], higher value when closer to the tropical
#' @export
evatransPotential_PriestleyTaylor <- function(ATMOS_temperature_Cel, ATMOS_netRadiat_MJ, LAND_elevation_m, param_EVATRANS_prt_alpha) {
    .Call(`_HydroGallery_evatransPotential_PriestleyTaylor`, ATMOS_temperature_Cel, ATMOS_netRadiat_MJ, LAND_elevation_m, param_EVATRANS_prt_alpha)
}

#' **actuall evapotranspiration**
#' @name evatransActual
#' @inheritParams all_vari
#' @description
#' \loadmathjax
#' Actual ET, or actual evapotranspiration, is a measure of the amount of water that is lost from the land surface through evaporation and transpiration by plants.
#' 
#' Under the concept of the conceptual HM, the actual ET is always calculated by the potential ET \mjseqn{E_p}, which evaluates the meteorological and landuse (vegetation) situations. 
#' The second point to consider is the water availability of the land or soil.
#' 
#' So we can give the function from:
#' 
#' \mjsdeqn{E_a = f_{evatransActual}(D_{atms}, D_{lssg})}
#' 
#' 
#' to:
#' 
#' \mjsdeqn{E_a = f_{evatransActual}(E_p, W_{lssg}, ...) = k^* E_p}
#' 
#' where
#' - \mjseqn{E_a} is `LAND_evatrans_mm` or `soil_evatrans_mm`
#' - \mjseqn{E_p} is `ATMOS_potentialEvatrans_mm`
#' - \mjseqn{k^*} is estimated ratio.
#' 
#' Then the different `evatransActual` methods will estimate the ratio \mjseqn{k^*}.
#' 
#' The output density distribution from 7 methods:
#'
#' @references
#' \insertAllCited{}
#' @return actually ET in (mm/m2/TS)
#' - evaporation in interception (landLy), `LAND_evatrans_mm`
#' - transpiration in root
#' - evaporation in soil (soilLy), `soil_evatrans_mm`
#' @details
#' # **_SupplyRatio**: 
#'
#' 
#' The water content (the ratio to the maximal capacity) 
#' is considered as th main factors for the ratio \mjseqn{k^*}.
#' \mjsdeqn{k^* = k  \frac{W}{C}}
#' where
#'   - \mjseqn{W} is water volume in (mm/m2/TS), `water_mm`, `LAND_interceptWater_mm`, `soil_water_mm`
#'   - \mjseqn{C} is water capacity in (mm/m2), `capacity_mm`, `LAND_interceptCapacity_mm`, `soil_capacity_mm`
#'   - \mjseqn{k} is `param_EVATRANS_sur_k`
#' @param param_EVATRANS_sur_k <0.1, 1> parameter for [evatransActual_SupplyRatio()], ratio of potential ET, that is estimated as actually ET  
#' @export
evatransActual_SupplyRatio <- function(ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_sur_k) {
    .Call(`_HydroGallery_evatransActual_SupplyRatio`, ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_sur_k)
}

#' @rdname evatransActual
#' @details
#' # **_SupplyPow**: 
#'
#' 
#' The water content (the ratio to the maximal capacity) 
#' is considered as th main factors for the ratio \mjseqn{k^*}.
#' \mjsdeqn{k^* = k  \left(\frac{W}{C}\right)^\gamma}
#' where
#'   - \mjseqn{k} is `param_EVATRANS_sup_k`
#'   - \mjseqn{\gamma} is `param_EVATRANS_sup_gamma`
#' @param param_EVATRANS_sup_k <0.1, 1> parameter for [evatransActual_SupplyPow()], ratio of this method
#' @param param_EVATRANS_sup_gamma <1, 5> parameter for [evatransActual_SupplyPow()], exponent of this method
#' @export
evatransActual_SupplyPow <- function(ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_sup_k, param_EVATRANS_sup_gamma) {
    .Call(`_HydroGallery_evatransActual_SupplyPow`, ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_sup_k, param_EVATRANS_sup_gamma)
}

#' @rdname evatransActual
#' @details
#' # **_VIC** \insertCite{VIC_Wood_1992}{HydroGallery}: 
#'
#' 
#' This method is similar with [evatransActual_SupplyPow()], estimate the water content in the storage.
#' \mjsdeqn{k^* = 1-\left(1-\frac{W}{C}\right)^{\gamma}}
#' where
#'   - \mjseqn{\gamma} is `param_EVATRANS_vic_gamma`
#' @param param_EVATRANS_vic_gamma <0.2, 5> parameter for [evatransActual_VIC()]
#' @export
evatransActual_VIC <- function(ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_vic_gamma) {
    .Call(`_HydroGallery_evatransActual_VIC`, ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_vic_gamma)
}

#' @rdname evatransActual
#' @details
#' # **_GR4J** \insertCite{GR4J_Perrin_2003}{HydroGallery}: 
#'
#' 
#' It is a little different than other method, it estimate not the ratio \mjseqn{f},
#' rather dieectly a equation with potential ET and water content.
#' And it need **no parameter**.
#' \mjsdeqn{E_a = \frac{W\left(2-\frac{W}{C}\right)\tanh \left(\frac{E_p}{C}\right)}{1 + \left(1-\frac{W}{C}\right)\tanh \left(\frac{E_p}{C}\right)}}
#' @export
evatransActual_GR4J <- function(ATMOS_potentialEvatrans_mm, water_mm, capacity_mm) {
    .Call(`_HydroGallery_evatransActual_GR4J`, ATMOS_potentialEvatrans_mm, water_mm, capacity_mm)
}

#' @rdname evatransActual
#' @details
#' # **_UBC** \insertCite{UBC_Quick_1977}{HydroGallery}: 
#'
#' 
#' It estimates the water content in the storage. 
#' (This is a little different than original, the parameter `P0AGEN` is replaced by \mjseqn{\frac{C}{\gamma}}.)
#' \mjsdeqn{k^* = 10^{\gamma \frac{W-C}{C}}}
#' where
#'   - \mjseqn{\gamma} is `param_EVATRANS_ubc_gamma`
#' @param param_EVATRANS_ubc_gamma <0.5, 2> parameter for [evatransActual_UBC()]
#' @export
evatransActual_UBC <- function(ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_ubc_gamma) {
    .Call(`_HydroGallery_evatransActual_UBC`, ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_ubc_gamma)
}

#' @rdname evatransActual
#' 
#' @details
#' # **_LiangLand** \insertCite{VIC2_Liang_1994}{HydroGallery}: 
#'
#' 
#' It is also a similar method like [evatransActual_SupplyPow()], 
#' but it will estimate the supply ability agian, whwn the water is still not enough.
#' \mjsdeqn{E_a^* = \left(\frac{W}{C}\right)^\gamma E_p}
#' \mjsdeqn{E_a = \min \left(1, \frac{W}{E_a^*}\right) E_a^*}
#' where
#'   - \mjseqn{E_l^*} is the first estimated actuall ET
#'   - \mjseqn{E_l} is actuall ET from land, `LAND_evatrans_mm`
#'   - \mjseqn{\gamma} is `param_EVATRANS_lia_gamma`
#' @param param_EVATRANS_lia_gamma <0.4, 1> parameter for [evatransActual_LiangLand()]
#' @export
evatransActual_LiangLand <- function(ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_lia_gamma) {
    .Call(`_HydroGallery_evatransActual_LiangLand`, ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_lia_gamma)
}

#' @rdname evatransActual
#' @details
#' # **_LiangSoil** \insertCite{VIC2_Liang_1994}{HydroGallery}: 
#'
#' 
#' It estimates the water content in the storage. 
#' (This is a little different than original, the parameter `P0AGEN` is replaced by \mjseqn{\frac{C}{\gamma}}.)
#' \mjsdeqn{k^* = \int_{0}^{A_{s}} {\rm d} A + \int_{A_{s}}^{1} \frac{i_{0}}{i_{m} [1-(1-A)^{1 / B} ]} {\rm d} A }
#' where
#'   - \mjseqn{B} is `param_EVATRANS_lia_B`
#'   - \mjseqn{A} is fraction of area
#' 
#' ![](liang_evatransSoil.png)
#' @param param_EVATRANS_lia_B <0.01, 3> parameter for [evatransActual_LiangSoil()]
#' @export
evatransActual_LiangSoil <- function(ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_lia_B) {
    .Call(`_HydroGallery_evatransActual_LiangSoil`, ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_lia_B)
}

#' @rdname evatransActual
#' @param param_EVATRANS_wat_petmax <10, 20> parameter for [evatransActual_WaterGAP()], 10 for arid area, 20 for humid area
#' @export
evatransActual_WaterGAP3 <- function(ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_wat_petmax) {
    .Call(`_HydroGallery_evatransActual_WaterGAP3`, ATMOS_potentialEvatrans_mm, water_mm, capacity_mm, param_EVATRANS_wat_petmax)
}

#' **infiltration**
#' @name infilt
#' @inheritParams all_vari
#' @description
#' \loadmathjax
#' In hydrological modeling, infiltration refers to the process by which water from precipitation snowmelt or irrigation enters the soil \insertCite{Handbook_Hydrology_1993}{HydroGallery}. 
#' 
#' Under the concept of the conceptual HM, the flux of infiltration is always calculated by the amount of water on the land \mjseqn{W_{land}}, 
#' which can be precipitation, precipitation after interception, or precipitation with snowmelt, among others. 
#' The second point to consider is the water acceptability of the soil layer (\mjseqn{C_{soil} - W_{soil}}).
#' 
#' So we can give the function from:
#' 
#' \mjsdeqn{F_{iflt} = f_{infilt}(D_{land}, D_{soil})}
#' 
#' 
#' to:
#' 
#' \mjsdeqn{F_{iflt} = f_{infilt}(W_{land}, W_{soil}, C_{soil}, ...)}
#' 
#' some methods will tread the infiltartion as the part of th pounded water so there is also:
#' 
#' \mjsdeqn{F_{iflt} = k^* W_{land}}
#' 
#' 
#' where
#' - \mjseqn{F_{iflt}} is `infilt_mm`
#' - \mjseqn{W_{land}} is `LAND_water_mm`
#' - \mjseqn{W_{soil}} is `SOIL_water_mm`
#' - \mjseqn{C_{soil}} is `SOIL_capacity_mm`
#' - \mjseqn{k^*} is estimated ratio.
#' 
#' The output density distribution from 9 methods:
#'
#' @references
#' \insertAllCited{}
#' @return flux of infiltration from land surface to soil layer
#' 
#' @details
#' # **_GR4J** \insertCite{GR4J_Perrin_2003}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{F_{iflt}=\frac{C_{soil}\left(1-\left(\frac{W_{soil}}{C_{soil}}\right)^{2}\right) \tanh \left(\frac{W_{land}}{C_{soil}}\right)}{1+\frac{W_{soil}}{C_{soil}} \tanh \left(\frac{W_{land}}{C_{soil}}\right)}}
#' @export
infilt_GR4J <- function(LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm) {
    .Call(`_HydroGallery_infilt_GR4J`, LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm)
}

#' @rdname infilt
#' @param param_INFILT_ubc_P0AGEN <0.1, 4> coefficient parameter for [infilt_UBC()]
#' @details
#' # **_UBC** \insertCite{UBC_Quick_1977}{HydroGallery}: 
#'
#' 
#' estimate the ratio \mjseqn{k^*} as:
#' \mjsdeqn{k^* = p_{imper} 10^{\frac{W_{soil}-C_{soil}}{p_{AGEN}}}}
#' where
#'   - \mjseqn{p_{imper}} is `LAND_impermeableFrac_1`
#'   - \mjseqn{p_{AGEN}} is `param_INFILT_ubc_P0AGEN`
#' @export
infilt_UBC <- function(LAND_water_mm, LAND_impermeableFrac_1, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_ubc_P0AGEN) {
    .Call(`_HydroGallery_infilt_UBC`, LAND_water_mm, LAND_impermeableFrac_1, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_ubc_P0AGEN)
}

#' @rdname infilt
#' @details
#' # **_SupplyRatio**: 
#'
#' 
#' is a very simple method, which estimate only the pounded water:
#' \mjsdeqn{k^* = k}
#' where
#'   - \mjseqn{k} is `param_INFILT_sur_k`
#' @param param_INFILT_sur_k <0.01, 1> coefficient parameter for [infilt_SupplyRatio()]
#' @return infilt_mm (mm/m2) 
#' @export
infilt_SupplyRatio <- function(LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_sur_k) {
    .Call(`_HydroGallery_infilt_SupplyRatio`, LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_sur_k)
}

#' @rdname infilt
#' @details
#' # **_AcceptRatio**: 
#'
#' 
#' \mjsdeqn{F_{iflt} = k (C_{soil} - W_{soil})}
#' where
#'   - \mjseqn{k} is `param_INFILT_acr_k`
#' @param param_INFILT_acr_k <0.01, 1> coefficient parameter for [infilt_AcceptRatio()]
#' @export
infilt_AcceptRatio <- function(LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_acr_k) {
    .Call(`_HydroGallery_infilt_AcceptRatio`, LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_acr_k)
}

#' @rdname infilt
#' @details
#' # **_SupplyPow**: 
#'
#' 
#' is a very simple method, which estimate only the pounded water:
#' \mjsdeqn{F_{iflt} = kW_{land}^{\gamma}}
#' where
#'   - \mjseqn{k} is `param_INFILT_sup_k`
#'   - \mjseqn{\gamma} is `param_INFILT_sup_gamma`
#' @param param_INFILT_sup_k <0.01, 1> coefficient parameter for [infilt_SupplyPow()]
#' @param param_INFILT_sup_gamma <0, 1> parameters for [infilt_SupplyPow()]
#' @export
infilt_SupplyPow <- function(LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_sup_k, param_INFILT_sup_gamma) {
    .Call(`_HydroGallery_infilt_SupplyPow`, LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_sup_k, param_INFILT_sup_gamma)
}

#' @rdname infilt
#' @details
#' # **_AcceptPow**: 
#'
#' 
#' \mjsdeqn{F_{iflt} = k \left(\frac{C_{soil} - W_{soil}}{C_{soil}} \right)^{\gamma}}
#' where
#'   - \mjseqn{k} is `param_INFILT_acp_k`
#'   - \mjseqn{\gamma} is `param_INFILT_acp_gamma`
#' @param param_INFILT_acp_k <0.01, 1> coefficient parameter for [infilt_AcceptPow()]
#' @param param_INFILT_acp_gamma <0.001, 5> parameters for [infilt_AcceptPow()]
#' @export
infilt_AcceptPow <- function(LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_acp_k, param_INFILT_acp_gamma) {
    .Call(`_HydroGallery_infilt_AcceptPow`, LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_acp_k, param_INFILT_acp_gamma)
}

#' @rdname infilt
#' @details
#' # **_HBV** \insertCite{HBV_Lindstrom_1997}{HydroGallery}: 
#'
#' 
#' estimate the ratio \mjseqn{k^*} as:
#' \mjsdeqn{k^* = 1-\left(\frac{W_{soil}}{C_{soil}}\right)^{\beta}}
#' where
#'   - \mjseqn{\beta} is `param_INFILT_hbv_beta`
#' @param param_INFILT_hbv_beta <0.001, 5> parameters for [infilt_HBV()]
#' @export
infilt_HBV <- function(LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_hbv_beta) {
    .Call(`_HydroGallery_infilt_HBV`, LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_hbv_beta)
}

#' @rdname infilt
#' @details
#' # **_XAJ** \insertCite{XAJ_Zhao_1992}{HydroGallery}:
#'
#' 
#' \mjsdeqn{F_{iflt} = MM  \frac{\left( \frac{MM - AU}{MM} \right)^{B+1} - \left( \frac{MM - AU - W_{land}}{MM} \right)^{B+1}}{B+1}}
#' \mjsdeqn{AU = MM - \left( \frac{(1 - W_{soil})(B+1)}{MM} \right)^{1 / B - 1}  }
#' \mjsdeqn{MM = C_{soil}(B+1)  }
#' where
#'   - \mjseqn{B} is `param_INFILT_xaj_B`
#' 
#' ![](xaj_infilt.png)
#' 
#' @param param_INFILT_xaj_B <0.01, 3> parameters for [infilt_XAJ()]
#' @export
infilt_XAJ <- function(LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_xaj_B) {
    .Call(`_HydroGallery_infilt_XAJ`, LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_xaj_B)
}

#' @rdname infilt
#' @details
#' # **_VIC** \insertCite{VIC_Wood_1992}{HydroGallery}:
#'
#' 
#' \mjsdeqn{F_{infilt} = \int_{i_{0}}^{i_{0}+P} A(i) {\rm d} i}
#' \mjsdeqn{i = C_{soil}(B+1) \left[ 1 - (1-A)^{1/B} \right]}
#' where
#'   - \mjseqn{B} is `param_INFILT_vic_B`
#' @param param_INFILT_vic_B <0.01, 3> parameters for [infilt_VIC()]
#' @export
infilt_VIC <- function(LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_vic_B) {
    .Call(`_HydroGallery_infilt_VIC`, LAND_water_mm, SOIL_water_mm, SOIL_capacity_mm, param_INFILT_vic_B)
}

#' **interflow**
#' @name inteflow
#' @inheritParams all_vari
#' @description
#' \loadmathjax
#' 
#' In hydrological modeling, interflow refers to the movement of water that is transported horizontally through the soil or aquifer.
#' Like [baseflow], the impact of other RUs (response units) on the route to the river will be ignored.
#' 
#' It can be calculated by the water in the soil layer \mjseqn{W_{soil}},
#' which can also be tread as the part of the \mjseqn{W_{soil}}.
#' 
#' So we can give the function from:
#' 
#' \mjsdeqn{F_{itfl} = f_{inteflow}(D_{grnd}, D_{soil})}
#' 
#' 
#' to:
#' 
#' \mjsdeqn{F_{itfl} = f_{inteflow}(W_{soil}, C_{soil}, ...) = k^* W_{soil}}
#' \mjsdeqn{F_{itfl} \leq W_{soil}}
#' 
#' 
#' where
#' - \mjseqn{F_{itfl}} is `SOIL_inteflow_mm`
#' - \mjseqn{W_{soil}} is `water_SOIL_mm`
#' - \mjseqn{C_{soil}} is `capacity_SOIL_mm`
#' - \mjseqn{k^*} is estimated ratio
#' 
#' The output density distribution from 8 methods:
#'
#' @references
#' \insertAllCited{}
#' @return inteflow_mm (mm/m2)
#' @details
#' # **_GR4Jfix** \insertCite{GR4J_Perrin_2003}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{k^* = 1 - \left[ 1 + \left(k \frac{W_{soil}}{C_{soil}} \right)^\gamma \right]^{-1/\gamma}}
#' where
#'   - \mjseqn{k} is `param_INTEFLOW_grf_k`
#'   - \mjseqn{\gamma} is `param_baseflow_grf_gamma`
#' @param param_INTEFLOW_grf_k <0.01, 1> coefficient parameter for [inteflow_GR4Jfix()]
#' @param param_INTEFLOW_grf_gamma <2, 7> exponential parameter for [baseflow_GR4Jfix()]
#' @export
inteflow_GR4Jfix <- function(SOIL_water_mm, SOIL_capacity_mm, param_INTEFLOW_grf_k, param_INTEFLOW_grf_gamma) {
    .Call(`_HydroGallery_inteflow_GR4Jfix`, SOIL_water_mm, SOIL_capacity_mm, param_INTEFLOW_grf_k, param_INTEFLOW_grf_gamma)
}

#' @rdname inteflow
#' @details
#' # **_MaxPow**: 
#'
#' 
#' \mjsdeqn{F_{itfl} = M_{itfl} \left(\frac{W_{soil}}{C_{soil}} \right)^\gamma}
#' where
#'   - \mjseqn{M_{itfl}} is `SOIL_potentialInteflow_mm`
#'   - \mjseqn{\gamma} is `param_INTEFLOW_map_gamma`
#' @param param_INTEFLOW_map_gamma <0.1, 5> exponential parameter for [inteflow_MaxPow()]
#' @export
inteflow_MaxPow <- function(SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialInteflow_mm, param_INTEFLOW_map_gamma) {
    .Call(`_HydroGallery_inteflow_MaxPow`, SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialInteflow_mm, param_INTEFLOW_map_gamma)
}

#' @rdname inteflow
#' @details
#' # **_ThreshPow** 
#'
#' 
#' based on the `_MaxPow` and add the one threshold \mjseqn{\phi_b}: 
#' \mjsdeqn{F_{itfl} = 0, \quad \frac{W_{soil}}{C_{soil}} < \phi_b}
#' \mjsdeqn{F_{itfl} = M_{itfl} \left(\frac{\frac{W_{soil}}{C_{soil}} - \phi_b}{1-\phi_b} \right)^\gamma, \quad \frac{W_{soil}}{C_{soil}} \geq \phi_b}
#' where
#'   - \mjseqn{\phi_b} is `param_INTEFLOW_thp_thresh`
#'   - \mjseqn{\gamma} is `param_INTEFLOW_thp_gamma`
#' @param param_INTEFLOW_thp_thresh <0.1, 0.9> coefficient parameter for [inteflow_ThreshPow()]
#' @param param_INTEFLOW_thp_gamma <0.1, 5> exponential parameter for [inteflow_ThreshPow()]
#' @export
inteflow_ThreshPow <- function(SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialInteflow_mm, param_INTEFLOW_thp_thresh, param_INTEFLOW_thp_gamma) {
    .Call(`_HydroGallery_inteflow_ThreshPow`, SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialInteflow_mm, param_INTEFLOW_thp_thresh, param_INTEFLOW_thp_gamma)
}

#' @rdname inteflow
#' @details
#' # **_Arno** \insertCite{baseflow_Arno_1991,VIC2_Liang_1994}{HydroGallery} 
#'
#' 
#' has also in two cases divided by a threshold water content \mjseqn{\phi_b}:
#' (*This method is actually not the original method, but an analogy with `inteflow_Arno`*) 
#' \mjsdeqn{F_{itfl} = k M_{itfl} \frac{W_{soil}}{C_{soil}}, \quad \frac{W_{soil}}{C_{soil}} < \phi_b}
#' \mjsdeqn{F_{itfl} = k M_{itfl} \frac{W_{soil}}{C_{soil}} + (1-k) M_{itfl} \left(\frac{W_{soil} - W_s}{C_{soil} - W_s} \right)^2, \quad \frac{W_{soil}}{C_{soil}} \geq \phi_b}
#' \mjsdeqn{W_s = k C_{soil}}
#' where
#'   - \mjseqn{\phi_b} is `param_INTEFLOW_arn_thresh`
#'   - \mjseqn{k} is `param_INTEFLOW_arn_k`
#' @param param_INTEFLOW_arn_thresh <0.1, 0.9> coefficient parameter for [inteflow_ThreshPow()]
#' @param param_INTEFLOW_arn_k <0.1, 1> exponential parameter for [inteflow_ThreshPow()]
#' @export
inteflow_Arno <- function(SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialInteflow_mm, param_INTEFLOW_arn_thresh, param_INTEFLOW_arn_k) {
    .Call(`_HydroGallery_inteflow_Arno`, SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialInteflow_mm, param_INTEFLOW_arn_thresh, param_INTEFLOW_arn_k)
}

#' @rdname inteflow
#' @details
#' # **_BevenWood** \insertCite{percola_BevenWood_1983,TOPMODEL_Beven_1995}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{k =  \frac{W_{soil}}{C_{soil} - W_{soil}} \quad {\rm and} \quad k \leq 1}
#' \mjsdeqn{F_{itfl} = k M_{itfl}}
#' where
#'   - \mjseqn{k_{fc}} is `SOIL_fieldCapacityPerc_1`
#'   - \mjseqn{\gamma} is `param_INTEFLOW_sup_gamma`
#' @export
inteflow_BevenWood <- function(SOIL_water_mm, SOIL_capacity_mm, SOIL_fieldCapacityPerc_1, SOIL_potentialInteflow_mm) {
    .Call(`_HydroGallery_inteflow_BevenWood`, SOIL_water_mm, SOIL_capacity_mm, SOIL_fieldCapacityPerc_1, SOIL_potentialInteflow_mm)
}

#' @rdname inteflow
#' @details
#' # **_SupplyPow0**: 
#'
#' 
#' \mjsdeqn{F_{base} = k(W_{grnd})^\gamma}
#' where
#'   - \mjseqn{k} is `param_INTEFLOW_sup_k`
#'   - \mjseqn{\gamma} is `param_INTEFLOW_sup_gamma`
#' @param param_INTEFLOW_sp0_k <0.01, 1> coefficient parameter for [inteflow_SupplyPow0()]
#' @param param_INTEFLOW_sp0_gamma <0, 1> exponential parameter for [inteflow_SupplyPow0()]
#' @export
inteflow_SupplyPow0 <- function(SOIL_water_mm, param_INTEFLOW_sp0_k, param_INTEFLOW_sp0_gamma) {
    .Call(`_HydroGallery_inteflow_SupplyPow0`, SOIL_water_mm, param_INTEFLOW_sp0_k, param_INTEFLOW_sp0_gamma)
}

#' @rdname inteflow
#' @details
#' # **_SupplyPow**: 
#'
#' 
#' \mjsdeqn{k^* = k \left(\frac{W_{soil}}{C_{soil}} \right)^\gamma}
#' where
#'   - \mjseqn{k} is `param_INTEFLOW_sup_k`
#'   - \mjseqn{\gamma} is `param_INTEFLOW_sup_gamma`
#' @param param_INTEFLOW_sup_k <0.01, 1> coefficient parameter for [inteflow_SupplyPow()]
#' @param param_INTEFLOW_sup_gamma <0, 7> parameter for [inteflow_SupplyPow()]
#' @export
inteflow_SupplyPow <- function(SOIL_water_mm, SOIL_capacity_mm, param_INTEFLOW_sup_k, param_INTEFLOW_sup_gamma) {
    .Call(`_HydroGallery_inteflow_SupplyPow`, SOIL_water_mm, SOIL_capacity_mm, param_INTEFLOW_sup_k, param_INTEFLOW_sup_gamma)
}

#' @rdname inteflow
#' @details
#' # **_SupplyRatio**: 
#'
#' 
#' \mjsdeqn{k^* = k}
#' where
#'   - \mjseqn{k} is `param_INTEFLOW_sur_k`
#' @param param_INTEFLOW_sur_k <0.01, 1> coefficient parameter for [inteflow_SupplyRatio()]
#' @export
inteflow_SupplyRatio <- function(SOIL_water_mm, param_INTEFLOW_sur_k) {
    .Call(`_HydroGallery_inteflow_SupplyRatio`, SOIL_water_mm, param_INTEFLOW_sur_k)
}

#' **interception** water from land go into the soil.
#' @name intercep
#' @inheritParams all_vari
#' @description 
#' \loadmathjax
#' 
#' In hydrological modeling, interception refers to the process by which water from precipitation is temporarily retained on the surfaces of vegetation, such as leaves and branches, before being returned to the atmosphere through evaporation or drip.
#' 
#' Under the concept of the conceptional HM, the interception will simply be calculated with the maximal interception of the land.
#' And the interception water will also not go to the land, but will be evaporated.
#' The maximal Interception of the canopy is maybe difficult to estimate 
#' but the process is really simple and there is also not so many method to describe it. 
#' 
#' @details
#' # **_Full** : 
#' 
#'
#' 
#' consider only the radiation and temperature as the main factors. 
#' \mjsdeqn{F_{itcp} = C_{icpt} - W_{icpt}}
#' where
#'   - \mjseqn{F_{icp}} is `intercept_water_mm`
#'   - \mjseqn{C_{icpt}} is `LAND_intercepCapaciy_mm`
#'   - \mjseqn{W_{icpt}} is `LAND_intercepWater_mm`
#' @return intercept_water_mm (mm/m2) intercepted water in this timestep
#' @export
intercep_Full <- function(ATMOS_precipitation_mm, LAND_interceptWater_mm, LAND_interceptCapacity_mm) {
    .Call(`_HydroGallery_intercep_Full`, ATMOS_precipitation_mm, LAND_interceptWater_mm, LAND_interceptCapacity_mm)
}

#' **lake outflow**
#' @name lakeout
#' @description
#'
#' The concept of lake estimates the waterbody outflow for waternet concentation
#' @inheritParams all_vari
#' @param param_Lakeout_sup_storeFactor <uknow> parameter for [lakeout_SupplyPow()],
#' @param param_Lakeout_sup_gamma <uknow> parameter for [lakeout_SupplyPow()],
#' @return outflow (m3)
#' @export
lakeout_SupplyPow <- function(Lake_water_m3, Lake_capacity_m3, param_Lakeout_sup_storeFactor, param_Lakeout_sup_gamma) {
    .Call(`_HydroGallery_lakeout_SupplyPow`, Lake_water_m3, Lake_capacity_m3, param_Lakeout_sup_storeFactor, param_Lakeout_sup_gamma)
}

#' **lake evaporation**
#' @name lakevap
#' @description
#'
#' The concept of lake estimates the waterbody outflow for waternet concentation
#' @inheritParams all_vari
#' @return evaporation o flake area (mm / day)
#' @export
lakeevap_Zhao <- function(ATMOS_solarRadiat_MJ, ATMOS_temperature_Cel, ATMOS_vaporPress_kPa, ATMOS_windSpeed2m_m_s, LAND_latitude_Degree, LAND_elevation_m, Lake_temperature_Cel, Lake_depth_m, Lake_area_km2, Lake_fetchLength_m, Time_dayOfYear) {
    .Call(`_HydroGallery_lakeevap_Zhao`, ATMOS_solarRadiat_MJ, ATMOS_temperature_Cel, ATMOS_vaporPress_kPa, ATMOS_windSpeed2m_m_s, LAND_latitude_Degree, LAND_elevation_m, Lake_temperature_Cel, Lake_depth_m, Lake_area_km2, Lake_fetchLength_m, Time_dayOfYear)
}

#' **lateral flux**
#' @name lateral
#' @inheritParams all_vari
#' @description
#' \loadmathjax
#' 
#' In hydrological modeling, lateral flow refers to the process by which water flows horizontally through the soil or aquifer, rather than vertically.
#' It is typically represented by a loss term in the water balance equation, so it also named as groundwater exchange (e.g. GR4J \insertCite{GR4J_Perrin_2003}{HydroGallery}).
#' The flux of lateral exchange is always calculated (only) by the water in the ground layer \mjseqn{W_{grnd}}. 
#' Unlike other fluxes, the lateral exchange can be positive or negative, 
#' with positive indicating a supply from other regions and negative indicating distribution to other regions.
#' 
#' This process is so flexible that we must carefully use it, 
#' because it can easily destroy the waster balance in the research catchment.
#' 
#' \mjsdeqn{F_{ltrl} = f_{lateral}(D_{grnd})}
#' 
#' 
#' to:
#' 
#' \mjsdeqn{F_{ltrl} = f_{lateral}(W_{grnd}, C_{grnd}, ...)}
#' 
#' 
#' where
#' - \mjseqn{W_{grnd}} is `GROUND_water_mm`
#' - \mjseqn{C_{grnd}} is `GROUND_capacity_mm`, but not all the methods need the \mjseqn{C_{grnd}}
#' 
#' The output density distribution from 6 methods:
#'
#' @references
#' \insertAllCited{}
#' @return lateral_mm (mm/m2)
#' 
#' 
#' 
#' @details
#' # **_SupplyPow**: 
#'
#' 
#' \mjsdeqn{F_{ltrl} = k \left( \frac{W_{grnd}}{C_{grnd}} \right)^\gamma  W_{grnd}}
#' where
#'   - \mjseqn{k} is `param_LATERAL_sup_k`
#'   - \mjseqn{\gamma} is `param_LATERAL_sup_gamma`
#' @param param_LATERAL_sup_k <-1, 1> coefficient parameter for [lateral_SupplyPow()]
#' @param param_LATERAL_sup_gamma <0.01, 5> parameters for [lateral_SupplyPow()]
#' @export
lateral_SupplyPow <- function(GROUND_water_mm, GROUND_capacity_mm, param_LATERAL_sup_k, param_LATERAL_sup_gamma) {
    .Call(`_HydroGallery_lateral_SupplyPow`, GROUND_water_mm, GROUND_capacity_mm, param_LATERAL_sup_k, param_LATERAL_sup_gamma)
}

#' @rdname lateral
#' @details
#' # **_SupplyRatio**: 
#'
#' 
#' \mjsdeqn{F_{ltrl} = k * W_{grnd}}
#' where
#'   - \mjseqn{k} is `param_LATERAL_sur_k`
#' @param param_LATERAL_sur_k <-2, 1> coefficient parameter for [lateral_SupplyRatio()]
#' @export
lateral_SupplyRatio <- function(GROUND_water_mm, param_LATERAL_sur_k) {
    .Call(`_HydroGallery_lateral_SupplyRatio`, GROUND_water_mm, param_LATERAL_sur_k)
}

#' @rdname lateral
#' @details
#' # **_GR4J** \insertCite{GR4J_Perrin_2003}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{F_{ltrl} = M_{ltrl} \left( \frac{W_{grnd}}{C_{grnd}} \right)^{7/2}  }
#' where
#'   - \mjseqn{M_{ltrl}} is `GROUND_potentialLateral_mm`
#' @export
lateral_GR4J <- function(GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialLateral_mm) {
    .Call(`_HydroGallery_lateral_GR4J`, GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialLateral_mm)
}

#' @rdname lateral
#' @details
#' # **_GR4Jfix** \insertCite{GR4J_Perrin_2003}{HydroGallery} 
#'
#' 
#' based on `_GR4J` use a new parameter to replace the numer 4: 
#' \mjsdeqn{F_{ltrl} = M_{ltrl} \left( \frac{W_{grnd}}{C_{grnd}} \right)^\gamma  }
#' where
#'   - \mjseqn{\gamma} is `param_LATERAL_grf_gamma`
#' @param param_LATERAL_grf_gamma <0.01, 5> parameter for [lateral_GR4Jfix()]
#' @export
lateral_GR4Jfix <- function(GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialLateral_mm, param_LATERAL_grf_gamma) {
    .Call(`_HydroGallery_lateral_GR4Jfix`, GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialLateral_mm, param_LATERAL_grf_gamma)
}

#' @rdname lateral
#' @details
#' # **_ThreshPow** 
#'
#' 
#' based on the `_GR4Jfix` and add the one threshold \mjseqn{\phi_b}: 
#' \mjsdeqn{F_{ltrl} = 0, \quad \frac{W_{grnd}}{C_{grnd}} < \phi_b}
#' \mjsdeqn{F_{ltrl} = M_{ltrl} \left(\frac{\frac{W_{grnd}}{C_{grnd}} - \phi_b}{1-\phi_b} \right)^\gamma, \quad \frac{W_{grnd}}{C_{grnd}} \geq \phi_b}
#' where
#'   - \mjseqn{\phi_b} is `param_LATERAL_thp_thresh`
#'   - \mjseqn{\gamma} is `param_LATERAL_thp_gamma`
#' @param param_LATERAL_thp_thresh <0.1, 0.9> coefficient parameter for [lateral_ThreshPow()]
#' @param param_LATERAL_thp_gamma <0.1, 5> exponential parameter for [lateral_ThreshPow()]
#' @export
lateral_ThreshPow <- function(GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialLateral_mm, param_LATERAL_thp_thresh, param_LATERAL_thp_gamma) {
    .Call(`_HydroGallery_lateral_ThreshPow`, GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialLateral_mm, param_LATERAL_thp_thresh, param_LATERAL_thp_gamma)
}

#' @rdname lateral
#' @details
#' # **_Arno** \insertCite{baseflow_Arno_1991,VIC2_Liang_1994}{HydroGallery} 
#'
#' 
#' has also in two cases divided by a threshold water content \mjseqn{\phi_b}: 
#' \mjsdeqn{F_{ltrl} = k M_{ltrl} \frac{W_{grnd}}{C_{grnd}}, \quad \frac{W_{grnd}}{C_{grnd}} < \phi_b}
#' \mjsdeqn{F_{ltrl} = k M_{ltrl} \frac{W_{grnd}}{C_{grnd}} + (1-k) M_{ltrl} \left(\frac{W_{grnd} - W_s}{C_{grnd} - W_s} \right)^2, \quad \frac{W_{grnd}}{C_{grnd}} \geq \phi_b}
#' \mjsdeqn{W_s = k C_{grnd}}
#' where
#'   - \mjseqn{\phi_b} is `param_LATERAL_arn_thresh`
#'   - \mjseqn{k} is `param_LATERAL_arn_k`
#' @param param_LATERAL_arn_thresh <0.1, 0.9> coefficient parameter for [lateral_ThreshPow()]
#' @param param_LATERAL_arn_k <0.1, 1> exponential parameter for [lateral_ThreshPow()]
#' @export
lateral_Arno <- function(GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialLateral_mm, param_LATERAL_arn_thresh, param_LATERAL_arn_k) {
    .Call(`_HydroGallery_lateral_Arno`, GROUND_water_mm, GROUND_capacity_mm, GROUND_potentialLateral_mm, param_LATERAL_arn_thresh, param_LATERAL_arn_k)
}

#' **meteological variables**
#' some functions to calculate the meteological variables
#' @name meteo
#' @export
meteo_extraterreSolarRadiat_FAO56 <- function(Time_dayOfYear_, LAND_latitude_Degree) {
    .Call(`_HydroGallery_meteo_extraterreSolarRadiat_FAO56`, Time_dayOfYear_, LAND_latitude_Degree)
}

#' @rdname meteo
#' @inheritParams all_vari
#' @return meteological variables
#' @export
meteo_solarRadiatClearSky_FAO56 <- function(Time_dayOfYear_, LAND_latitude_Degree, LAND_elevation_m) {
    .Call(`_HydroGallery_meteo_solarRadiatClearSky_FAO56`, Time_dayOfYear_, LAND_latitude_Degree, LAND_elevation_m)
}

#' @rdname meteo
#' @export
meteo_saturatVaporPress <- function(ATMOS_temperature_Cel) {
    .Call(`_HydroGallery_meteo_saturatVaporPress`, ATMOS_temperature_Cel)
}

#' @rdname meteo
#' @export
meteo_saturatVaporPress_kPa <- function(ATMOS_temperature_Cel) {
    .Call(`_HydroGallery_meteo_saturatVaporPress_kPa`, ATMOS_temperature_Cel)
}

#' @rdname meteo
#' @export
meteo_vaporPress <- function(ATMOS_temperature_Cel, ATMOS_relativeHumidity_1) {
    .Call(`_HydroGallery_meteo_vaporPress`, ATMOS_temperature_Cel, ATMOS_relativeHumidity_1)
}

#' @rdname meteo
#' @export
meteo_nettoRadiat_FAO56 <- function(Time_dayOfYear_, ATMOS_temperature_Cel, ATMOS_temperatureMax_Cel, ATMOS_temperatureMin_Cel, ATMOS_relativeHumidity_1, ATMOS_solarRadiat_MJ, LAND_latitude_Degree, LAND_elevation_m) {
    .Call(`_HydroGallery_meteo_nettoRadiat_FAO56`, Time_dayOfYear_, ATMOS_temperature_Cel, ATMOS_temperatureMax_Cel, ATMOS_temperatureMin_Cel, ATMOS_relativeHumidity_1, ATMOS_solarRadiat_MJ, LAND_latitude_Degree, LAND_elevation_m)
}

#' @rdname meteo
#' @export
meteo_atmosEmissivity_FAO56 <- function(Time_dayOfYear_, ATMOS_temperature_Cel, ATMOS_relativeHumidity_1, ATMOS_solarRadiat_MJ, LAND_latitude_Degree, LAND_elevation_m) {
    .Call(`_HydroGallery_meteo_atmosEmissivity_FAO56`, Time_dayOfYear_, ATMOS_temperature_Cel, ATMOS_relativeHumidity_1, ATMOS_solarRadiat_MJ, LAND_latitude_Degree, LAND_elevation_m)
}

#' @rdname meteo
#' @export
meteo_cloudFactor_UNKNOW <- function(ATMOS_solarRadiat_MJ, Time_dayOfYear_, LAND_latitude_Degree, LAND_elevation_m) {
    .Call(`_HydroGallery_meteo_cloudFactor_UNKNOW`, ATMOS_solarRadiat_MJ, Time_dayOfYear_, LAND_latitude_Degree, LAND_elevation_m)
}

#' @rdname meteo
#' @export
meteo_atmosEmissivity_UNKNOW <- function(Time_dayOfYear_, ATMOS_temperature_Cel, ATMOS_vaporPress_kPa, ATMOS_solarRadiat_MJ, LAND_latitude_Degree, LAND_elevation_m) {
    .Call(`_HydroGallery_meteo_atmosEmissivity_UNKNOW`, Time_dayOfYear_, ATMOS_temperature_Cel, ATMOS_vaporPress_kPa, ATMOS_solarRadiat_MJ, LAND_latitude_Degree, LAND_elevation_m)
}

#' @rdname meteo
#' @export
meteo_atmosEmissivity_Idso <- function(ATMOS_temperature_Cel) {
    .Call(`_HydroGallery_meteo_atmosEmissivity_Idso`, ATMOS_temperature_Cel)
}

#' @rdname meteo
#' @export
meteo_nettoRadiat_WaterGAP3 <- function(ATMOS_temperature_Cel, ATMOS_solarRadiat_MJ, ATMOS_solarRadiatClearSky_MJ, LAND_albedo_1) {
    .Call(`_HydroGallery_meteo_nettoRadiat_WaterGAP3`, ATMOS_temperature_Cel, ATMOS_solarRadiat_MJ, ATMOS_solarRadiatClearSky_MJ, LAND_albedo_1)
}

#' @rdname meteo
#' @export
meteo_nettoRadiat_FAO56Simplify <- function(Time_dayOfYear_, ATMOS_temperature_Cel, ATMOS_relativeHumidity_1, ATMOS_solarRadiat_MJ, LAND_latitude_Degree, LAND_elevation_m) {
    .Call(`_HydroGallery_meteo_nettoRadiat_FAO56Simplify`, Time_dayOfYear_, ATMOS_temperature_Cel, ATMOS_relativeHumidity_1, ATMOS_solarRadiat_MJ, LAND_latitude_Degree, LAND_elevation_m)
}

#' @rdname meteo
#' @export
meteo_windSpeed2m <- function(ATMOS_windSpeed_m_s, ATMOS_windMeasureHeight_m) {
    .Call(`_HydroGallery_meteo_windSpeed2m`, ATMOS_windSpeed_m_s, ATMOS_windMeasureHeight_m)
}

#' @rdname meteo
#' @export
meteo_airDensity <- function(ATMOS_temperature_Cel, LAND_elevation_m) {
    .Call(`_HydroGallery_meteo_airDensity`, ATMOS_temperature_Cel, LAND_elevation_m)
}

#' @rdname meteo
#' @export
meteo_saturatDelta <- function(ATMOS_temperature_Cel) {
    .Call(`_HydroGallery_meteo_saturatDelta`, ATMOS_temperature_Cel)
}

meteo_wetBulbTemperature <- function(ATMOS_vaporPress_kPa, ATMOS_temperature_Cel) {
    .Call(`_HydroGallery_meteo_wetBulbTemperature`, ATMOS_vaporPress_kPa, ATMOS_temperature_Cel)
}

#' **percolation**
#' @name percola
#' @inheritParams all_vari
#' @description
#' \loadmathjax
#' 
#' In hydrological modeling, percolation refers to the process by which water from the soil moves downward through the pores and cracks in the soil or rock.
#' This process is physically driven by a moisture gradient, but this is often simplified in conceptual percolation models \insertCite{Raven_Manual_35}{HydroGallery}.
#' It can be calculated by the water in the soil layer \mjseqn{W_{soil}},
#' it can also be tread as the part of the \mjseqn{W_{soil}}.
#' 
#' So we can give the function from:
#' 
#' \mjsdeqn{F_{prcl} = f_{percola}(D_{grnd}, D_{soil})}
#' 
#' 
#' to:
#' 
#' \mjsdeqn{F_{prcl} = f_{percola}(W_{soil}, C_{soil}, W_{grnd}, C_{grnd}, ...) = k^* W_{soil}}
#' \mjsdeqn{F_{prcl} \leq W_{soil}}
#' \mjsdeqn{F_{prcl} \leq C_{grnd} - W_{grnd}}
#' 
#' 
#' where
#' - \mjseqn{F_{prcl}} is `SOIL_percola_mm`
#' - \mjseqn{W_{soil}} is `water_SOIL_mm`
#' - \mjseqn{C_{soil}} is `capacity_SOIL_mm`
#' - \mjseqn{W_{grnd}} is `ground_water_mm`
#' - \mjseqn{C_{grnd}} is `capacity_water_mm`
#' - \mjseqn{k^*} is estimated ratio
#' 
#' The output density distribution from 8 methods:
#'
#' @references
#' \insertAllCited{}
#' @return percola_mm (mm/m2)
#' @details
#' # **_GR4J** \insertCite{GR4J_Perrin_2003}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{k^* = 1 - \left[ 1 + \left(\frac{4}{9} \frac{W_{soil}}{C_{soil}} \right)^4 \right]^{-1/4}}
#' where
#'   - \mjseqn{k^*} is estimated ratio
#' @export
percola_GR4J <- function(SOIL_water_mm, SOIL_capacity_mm) {
    .Call(`_HydroGallery_percola_GR4J`, SOIL_water_mm, SOIL_capacity_mm)
}

#' @rdname percola
#' @details
#' # **_GR4Jfix** \insertCite{GR4J_Perrin_2003}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{k^* = 1 - \left[ 1 + \left(k \frac{W_{soil}}{C_{soil}} \right)^4 \right]^{-1/4}}
#' where
#'   - \mjseqn{k} is `param_PERCOLA_grf_k`
#' @param param_PERCOLA_grf_k <0.01, 1> coefficient parameter for [percola_GR4Jfix()]
#' @export
percola_GR4Jfix <- function(SOIL_water_mm, SOIL_capacity_mm, param_PERCOLA_grf_k) {
    .Call(`_HydroGallery_percola_GR4Jfix`, SOIL_water_mm, SOIL_capacity_mm, param_PERCOLA_grf_k)
}

#' @rdname percola
#' @details
#' # **_MaxPow**: 
#'
#' 
#' \mjsdeqn{F_{prcl} = M_{prcl} \left(\frac{W_{soil}}{C_{soil}} \right)^\gamma}
#' where
#'   - \mjseqn{M_{prcl}} is `SOIL_potentialPercola_mm`
#'   - \mjseqn{\gamma} is `param_baseflow_map_gamma`
#' @param param_PERCOLA_map_gamma <0.1, 5> exponential parameter for [percola_MaxPow()]
#' @export
percola_MaxPow <- function(SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialPercola_mm, param_PERCOLA_map_gamma) {
    .Call(`_HydroGallery_percola_MaxPow`, SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialPercola_mm, param_PERCOLA_map_gamma)
}

#' @rdname percola
#' @details
#' # **_ThreshPow** 
#'
#' 
#' based on the `_MaxPow` and add the one threshold \mjseqn{\phi_b}: 
#' \mjsdeqn{F_{prcl} = 0, \quad \frac{W_{soil}}{C_{soil}} < \phi_b}
#' \mjsdeqn{F_{prcl} = M_{prcl} \left(\frac{\frac{W_{soil}}{C_{soil}} - \phi_b}{1-\phi_b} \right)^\gamma, \quad \frac{W_{soil}}{C_{soil}} \geq \phi_b}
#' where
#'   - \mjseqn{\phi_b} is `param_PERCOLA_thp_thresh`
#'   - \mjseqn{\gamma} is `param_PERCOLA_thp_gamma`
#' @param param_PERCOLA_thp_thresh <0.1, 0.9> coefficient parameter for [percola_ThreshPow()]
#' @param param_PERCOLA_thp_gamma <0.1, 5> exponential parameter for [percola_ThreshPow()]
#' @export
percola_ThreshPow <- function(SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialPercola_mm, param_PERCOLA_thp_thresh, param_PERCOLA_thp_gamma) {
    .Call(`_HydroGallery_percola_ThreshPow`, SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialPercola_mm, param_PERCOLA_thp_thresh, param_PERCOLA_thp_gamma)
}

#' @rdname percola
#' @details
#' # **_Arno** \insertCite{baseflow_Arno_1991,VIC2_Liang_1994}{HydroGallery} 
#'
#' 
#' has also in two cases divided by a threshold water content \mjseqn{\phi_b}:
#' (*This method is actually not the original method, but an analogy with `baseflow_Arno`*) 
#' \mjsdeqn{F_{prcl} = k M_{prcl} \frac{W_{soil}}{C_{soil}}, \quad \frac{W_{soil}}{C_{soil}} < \phi_b}
#' \mjsdeqn{F_{prcl} = k M_{prcl} \frac{W_{soil}}{C_{soil}} + (1-k) M_{prcl} \left(\frac{W_{soil} - W_s}{C_{soil} - W_s} \right)^2, \quad \frac{W_{soil}}{C_{soil}} \geq \phi_b}
#' \mjsdeqn{W_s = k C_{soil}}
#' where
#'   - \mjseqn{\phi_b} is `param_PERCOLA_arn_thresh`
#'   - \mjseqn{k} is `param_PERCOLA_arn_k`
#' @param param_PERCOLA_arn_thresh <0.1, 0.9> coefficient parameter for [percola_ThreshPow()]
#' @param param_PERCOLA_arn_k <0.1, 1> exponential parameter for [percola_ThreshPow()]
#' @export
percola_Arno <- function(SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialPercola_mm, param_PERCOLA_arn_thresh, param_PERCOLA_arn_k) {
    .Call(`_HydroGallery_percola_Arno`, SOIL_water_mm, SOIL_capacity_mm, SOIL_potentialPercola_mm, param_PERCOLA_arn_thresh, param_PERCOLA_arn_k)
}

#' @rdname percola
#' @details
#' # **_BevenWood** \insertCite{percola_BevenWood_1983,TOPMODEL_Beven_1995}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{k =  \frac{W_{soil}}{C_{soil} - W_{soil}} \quad {\rm and} \quad k \leq 1}
#' \mjsdeqn{F_{prcl} = k M_{prcl}}
#' where
#'   - \mjseqn{k_{fc}} is `SOIL_fieldCapacityPerc_1`
#'   - \mjseqn{\gamma} is `param_PERCOLA_sup_gamma`
#' @export
percola_BevenWood <- function(SOIL_water_mm, SOIL_capacity_mm, SOIL_fieldCapacityPerc_1, SOIL_potentialPercola_mm) {
    .Call(`_HydroGallery_percola_BevenWood`, SOIL_water_mm, SOIL_capacity_mm, SOIL_fieldCapacityPerc_1, SOIL_potentialPercola_mm)
}

#' @rdname percola
#' @details
#' # **_SupplyPow**: 
#'
#' 
#' \mjsdeqn{k^* = k \left(\frac{W_{soil}}{C_{soil}} \right)^\gamma}
#' where
#'   - \mjseqn{k} is `param_PERCOLA_sup_k`
#'   - \mjseqn{\gamma} is `param_PERCOLA_sup_gamma`
#' @param param_PERCOLA_sup_k <0.01, 1> coefficient parameter for [percola_SupplyPow()]
#' @param param_PERCOLA_sup_gamma <0, 7> parameter for [percola_SupplyPow()]
#' @export
percola_SupplyPow <- function(SOIL_water_mm, SOIL_capacity_mm, param_PERCOLA_sup_k, param_PERCOLA_sup_gamma) {
    .Call(`_HydroGallery_percola_SupplyPow`, SOIL_water_mm, SOIL_capacity_mm, param_PERCOLA_sup_k, param_PERCOLA_sup_gamma)
}

#' @rdname percola
#' @details
#' # **_SupplyRatio**: 
#'
#' 
#' \mjsdeqn{k^* = k}
#' where
#'   - \mjseqn{k} is `param_PERCOLA_sur_k`
#' @param param_PERCOLA_sur_k <0.01, 1> coefficient parameter for [percola_SupplyRatio()]
#' @export
percola_SupplyRatio <- function(SOIL_water_mm, param_PERCOLA_sur_k) {
    .Call(`_HydroGallery_percola_SupplyRatio`, SOIL_water_mm, param_PERCOLA_sur_k)
}

#' @rdname percola
#' @param param_PERCOLA_wat_01 <0, 1> 0: percolation, 1: non percolation [percola_WaterGAP3()]
#' @param param_PERCOLA_wat_thresh <10, 15> coefficient parameter for [percola_WaterGAP3()]
#' @param param_PERCOLA_wat_k <0.1, 1> exponential parameter for [percola_WaterGAP3()]
#' @export
percola_WaterGAP3 <- function(LAND_water_mm, SOIL_potentialPercola_mm, param_PERCOLA_wat_01, param_PERCOLA_wat_thresh, param_PERCOLA_wat_k) {
    .Call(`_HydroGallery_percola_WaterGAP3`, LAND_water_mm, SOIL_potentialPercola_mm, param_PERCOLA_wat_01, param_PERCOLA_wat_thresh, param_PERCOLA_wat_k)
}

#' **Reservoir releas**
#' @name reservoi
#' @inheritParams all_vari
#' @description
#'
#' The concept of river estimates the waterbody outflow for waternet concentation
#' @return outflow (m3)
#' @export
reservoireleas_Hanasaki <- function(Reservoi_water_m3, Reservoi_inflow_m3, Reservoi_demand_m3, Reservoi_capacity_m3, Reservoi_meanInflow_m3, Reservoi_meanDemand_m3, Reservoi_releaseCoefficient_1, Reservoi_isIrrigate_01) {
    .Call(`_HydroGallery_reservoireleas_Hanasaki`, Reservoi_water_m3, Reservoi_inflow_m3, Reservoi_demand_m3, Reservoi_capacity_m3, Reservoi_meanInflow_m3, Reservoi_meanDemand_m3, Reservoi_releaseCoefficient_1, Reservoi_isIrrigate_01)
}

#' @rdname reservoi
#' @param param_Reservoi_han_alpha <0,1> 0.85 parameter for [reservoireleasCoefficent_Hanasaki()],
#' @return new Reservoi_releaseCoefficient_1
#' @export
reservoiReleasCoefficent_Hanasaki <- function(Reservoi_water_m3, Reservoi_capacity_m3, Reservoi_releaseCoefficient_1, Reservoi_isOperateStart_01, param_Reservoi_han_alpha) {
    .Call(`_HydroGallery_reservoiReleasCoefficent_Hanasaki`, Reservoi_water_m3, Reservoi_capacity_m3, Reservoi_releaseCoefficient_1, Reservoi_isOperateStart_01, param_Reservoi_han_alpha)
}

#' **river outflow**
#' @name river
#' @inheritParams all_vari
#' @description
#'
#' The concept of river estimates the waterbody outflow for waternet concentation
#' @return outflow (m3)
#' @export
riverout_LinearResorvoir <- function(RIVER_water_m3, RIVER_inflow_m3, RIVER_velocity_km, RIVER_length_km) {
    .Call(`_HydroGallery_riverout_LinearResorvoir`, RIVER_water_m3, RIVER_inflow_m3, RIVER_velocity_km, RIVER_length_km)
}

#' @rdname river
#' @param param_Riverlak_lin_storeFactor <uknow> parameter for [riverlak_LinearResorvoir()],
#' @export
riverlakout_LinearResorvoir <- function(Riverlak_water_m3, Riverlak_inflow_m3, Riverlak_capacity_m3, param_Riverlak_lin_storeFactor) {
    .Call(`_HydroGallery_riverlakout_LinearResorvoir`, Riverlak_water_m3, Riverlak_inflow_m3, Riverlak_capacity_m3, param_Riverlak_lin_storeFactor)
}

#' @rdname routingtopology
#' @name get_inflow_cells
#' @title Get Inflow Cells
#' @description This function calculates inflow cells based on the outflow vector.
#' @param int_Outflow (vector of int) The cell number of the next cell. The cell number must range from 1 to the length of the cells.
#' If the cell has no outflow, the number should be set to itself.
#' @return A list where each element is an IntegerVector containing the inflow cells for each cell.
#' @export
get_inflow_cells <- function(int_Outflow) {
    .Call(`_HydroGallery_get_inflow_cells`, int_Outflow)
}

#' @rdname routingtopology
#' @name get_inflow_lastcell
#' @title Get Inflow Last Cell Matrix
#' @description This function creates a matrix of inflow cells for each cell based on the outflow vector.
#' @return A NumericMatrix where each row corresponds to a cell, and each column represents an inflow cell.
#' @export
get_inflow_lastcell <- function(int_Outflow) {
    .Call(`_HydroGallery_get_inflow_lastcell`, int_Outflow)
}

#' @rdname routingtopology
#' @title Get Step Parameters
#' @description This function returns a list of step cells and the corresponding last cell matrices.
#' @return A list containing the step cells and last cell matrices.
#' @export
get_routing_info <- function(int_Outflow) {
    .Call(`_HydroGallery_get_routing_info`, int_Outflow)
}

#' @rdname routingtopology
#' @param lst_Inflow_Cell A list of integer vectors, where each vector contains the cells that flow into the respective cell.
#' @param int_OutLet An integer representing the outlet cell (1-based index).
#' @param int_TestCell An integer vector, cells to test.
#' @return An integer vector of cells in the intersection of the station cells and the basin.
#' @export
get_cell_in_basin <- function(lst_Inflow_Cell, int_OutLet, int_TestCell) {
    .Call(`_HydroGallery_get_cell_in_basin`, lst_Inflow_Cell, int_OutLet, int_TestCell)
}

#' @rdname routingtopology
#' @param int_UpstreamCell An integer vector containing the upstream cells to find the upstream basin.
#' @return An integer vector representing the new upstream basin, which includes the upstream cells and the set difference of the basin cells.
#' This function identifies the upstream basin of a given outlet cell by first finding the intersection of the upstream cells
#' with the cells that flow into the outlet. It then computes the set difference between the upstream basin and the outlet basin.
#' @export
get_inter_basin <- function(lst_Inflow_Cell, int_OutLet, int_UpstreamCell) {
    .Call(`_HydroGallery_get_inter_basin`, lst_Inflow_Cell, int_OutLet, int_UpstreamCell)
}

#' @rdname routingtopology
#' @param int_Outflow_Ori An integer vector representing the original outflow indices (1-based).
#' @param int_CellNew An integer vector representing the cells within the new basin.
#' @return An integer vector of the new outflow indices adjusted for the sub-basin.
#' @export
get_new_outflow <- function(int_Outflow_Ori, int_CellNew) {
    .Call(`_HydroGallery_get_new_outflow`, int_Outflow_Ori, int_CellNew)
}

#' @rdname routingtopology
#' @param int_CaliCell An integer vector of calibration cells.
#' @return A list of integer vectors (`lst_Step_Cali`), where each element represents calibration cells at a specific step.
#' @export
get_cali_step <- function(lst_Inflow_Cell, int_CaliCell) {
    .Call(`_HydroGallery_get_cali_step`, lst_Inflow_Cell, int_CaliCell)
}

#' @rdname routingtopology
#' @return A list of integer vectors (`lst_Step_Cali`), where each element represents calibration cells at a specific step.
#' @export
get_upstream_cali_cell <- function(lst_Inflow_Cell, int_CaliCell) {
    .Call(`_HydroGallery_get_upstream_cali_cell`, lst_Inflow_Cell, int_CaliCell)
}

#' @rdname routingtopology
#' @export
write_int_vector_list <- function(lst, file_path) {
    invisible(.Call(`_HydroGallery_write_int_vector_list`, lst, file_path))
}

#' @rdname routingtopology
#' @export
read_int_vector_list <- function(file_path) {
    .Call(`_HydroGallery_read_int_vector_list`, file_path)
}

#' @rdname routingtopology
#' @export
write_int_matrix_list <- function(mat_list, file_path) {
    invisible(.Call(`_HydroGallery_write_int_matrix_list`, mat_list, file_path))
}

#' @rdname routingtopology
#' @export
read_int_matrix_list <- function(file_path) {
    .Call(`_HydroGallery_read_int_matrix_list`, file_path)
}

#' **snow**
#' @name snowMelt
#' @inheritParams all_vari
#' @description
#' \loadmathjax
#' 
#' Under the concept of the conceptual HM, the melt of snowpack is always calculated by 
#' the energy availability (the state-variable temperature \mjseqn{T} or flux-variable (nett-) radiation \mjseqn{Rn}) 
#' and the solid water (snow or ice) availability \mjseqn{W_{snow}} of the snowpack. 
#' 
#' Some more complex processes, such as refrozen and residual water, will be ignored. 
#' To simplify the model, the layer snowLy will store only the solid water and will melt it as much as possible when the energy is sufficient.
#' 
#' So we can give the function from:
#' 
#' \mjsdeqn{F_{melt} = f_{snowMelt}(D_{atms}, D_{snow})}
#' 
#' 
#' to:
#' \mjsdeqn{F_{melt}  = f_{snowMelt}(T, ...)}
#' \mjsdeqn{F_{melt} \leq W_{snow} }
#' 
#' where
#'   - \mjseqn{F_{melt}} is `SNOW_melt_mm`
#'   - \mjseqn{W_{snow}} is `SNOW_ice_mm`
#'   - \mjseqn{T} is average temperature
#' 
#' Then the different `snowMelt` methods will estimate the maximal snow melt \mjseqn{M_{max}}.
#' 
#' The output density distribution from 2 methods:
#'
#' @references
#' \insertAllCited{}
#' @return SNOW_melt_mm (mm/m2) melted snow
#' 
#' @details
#' # **_Kustas** \insertCite{SNOW_kustas_1994}{HydroGallery}: 
#' 
#'
#' 
#' \mjsdeqn{F_{melt}  = m_T T + m_E R_n}
#' but due to the temperature is one energy-state-variable, 
#' in order to adjust to subday scale we need to add a new time interval \mjseqn{t_h} from 1 to 24 hour
#' \mjsdeqn{F_{melt}  = m_T T t_h + m_E R_n}
#' where
#'   - \mjseqn{m_T} is `param_SNOWMELT_kus_fT`
#'   - \mjseqn{m_E} is `param_SNOWMELT_kus_fE`
#'   - \mjseqn{R_n} is daily net radiation
#' 
#' @param param_SNOWMELT_kus_fE <0.0005, 0.003> (mm/m2/MJ) snow melt temperature parameter for [snowMelt_Factor()]
#' @param param_SNOWMELT_kus_fT <0.05, 1> (mm/m2/h/Cel) potential melt volum per Cel per hour parameter for [snowMelt_Factor()]
#' @export
snowMelt_Kustas <- function(SNOW_ice_mm, ATMOS_temperature_Cel, ATMOS_netRadiat_MJ, param_SNOWMELT_kus_fE, param_SNOWMELT_kus_fT) {
    .Call(`_HydroGallery_snowMelt_Kustas`, SNOW_ice_mm, ATMOS_temperature_Cel, ATMOS_netRadiat_MJ, param_SNOWMELT_kus_fE, param_SNOWMELT_kus_fT)
}

#' @rdname snowMelt
#' @details
#' # **_Factor** \insertCite{phyHydro_dingman_2014}{HydroGallery}: 
#'
#' 
#' \mjsdeqn{F_{melt}  = m_T (T-T_b), \quad T > T_b}
#' where
#'   - \mjseqn{m_T} is `param_SNOWMELT_fac_f`
#'   - \mjseqn{T_b} is `param_SNOWMELT_fac_Tmelt`
#' 
#' @param param_SNOWMELT_fac_Tmelt <0, 3> (Cel) snow melt temperature parameter for [snowMelt_Factor()]
#' @param param_SNOWMELT_fac_f <0.5, 2> (mm/m2/day/Cel) potential melt volum per Cel per hour parameter for [snowMelt_Factor()]
#' @export
snowMelt_Factor <- function(SNOW_ice_mm, ATMOS_temperature_Cel, param_SNOWMELT_fac_f, param_SNOWMELT_fac_Tmelt) {
    .Call(`_HydroGallery_snowMelt_Factor`, SNOW_ice_mm, ATMOS_temperature_Cel, param_SNOWMELT_fac_f, param_SNOWMELT_fac_Tmelt)
}

#' Withdraw water
#' @name withdraw
#'
#' @description
#' [withdraw_SingleCell] This function handles water withdrawal from a single cell's water storage.
#' It updates the withdrawal deficit and the remaining water volume.
#'
#' @param CELL_withdrawal_m3 Vector of withdrawal requirements in cubic meters.
#'   This represents water demand and will be updated to reflect remaining deficit.
#' @param CELL_water_m3 Vector of available water volumes in cubic meters.
#'   This will be updated to reflect remaining water after withdrawal.
#' @return None. Parameters are updated by reference.
#' @export
withdraw_SingleCell <- function(CELL_withdrawal_m3, CELL_water_m3) {
    invisible(.Call(`_HydroGallery_withdraw_SingleCell`, CELL_withdrawal_m3, CELL_water_m3))
}

#' [withdrawSurface_AroundMax] This function identifies the surrounding cell with the maximum water availability
#' and withdraws water from it to satisfy the demand.
#' @rdname withdraw
#' @param CELL_cellNumberAround_int Matrix of cell indices that define surrounding cells.
#'   Each column corresponds to a cell, with rows containing indices of surrounding cells.
#' @return None. Parameters are updated by reference.
#' @export
withdrawSurface_AroundMax <- function(CELL_withdrawal_m3, RIVER_water_m3, Lake_water_m3, CELL_cellNumberAround_int) {
    invisible(.Call(`_HydroGallery_withdrawSurface_AroundMax`, CELL_withdrawal_m3, RIVER_water_m3, Lake_water_m3, CELL_cellNumberAround_int))
}

#' [withdrawSurface_Around] This function withdraws water from all surrounding cells proportionally
#' based on their water availability.
#' @rdname withdraw
#' @export
withdrawSurface_Around <- function(CELL_withdrawal_m3, RIVER_water_m3, Lake_water_m3, CELL_cellNumberAround_int) {
    invisible(.Call(`_HydroGallery_withdrawSurface_Around`, CELL_withdrawal_m3, RIVER_water_m3, Lake_water_m3, CELL_cellNumberAround_int))
}

#' [withdrawSurface_WithdrawNet] This function withdraws water by following a predefined network of cells
#' from which water can be withdrawn.
#' @name withdraw
#' @param CELL_cellNumberWithdrawNet_int Matrix defining the withdrawal network.
#'   Each column corresponds to a cell, with rows containing indices of cells
#'   from which water can be withdrawn in order of priority.
#' @export
withdrawSurface_WithdrawNet <- function(CELL_withdrawal_m3, RIVER_water_m3, Lake_water_m3, CELL_cellNumberWithdrawNet_int) {
    invisible(.Call(`_HydroGallery_withdrawSurface_WithdrawNet`, CELL_withdrawal_m3, RIVER_water_m3, Lake_water_m3, CELL_cellNumberWithdrawNet_int))
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call(`_HydroGallery_RcppExport_registerCCallable`)
})
